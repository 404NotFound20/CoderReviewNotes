# Manacher #

Manacher算法可以在O(n)的时间内求出一个字符串的最长回文子串。    
算法首先要保证源串是一个奇数长串，可以用插空法在源串中插入n+1个特殊字符（特殊是指源串中不会出现），这样构造后的串长度为2n+1为奇数。

为什么需要奇数长的字符串呢？因为Manacher算法是分别统计以某个字符为中心的最长回文子串，而偶数回文串不存在中心字符，通过以上插空法构造字符串，使得构造后的字符串也不会改变源字符串的回文性质。并且，当最后求得的最长回文子串的中心为插入的特殊字符时，说明对应的源回文（即去除特殊字符后）是偶数长的子串；当中心是源字符串中的字符时，对应的源回文是奇数长的子串。


笨方法的思路：

因此我们可以挨个遍历字符，求出每个字符为中心时的最长回文半径，最后返回这个最长半径对应的回文串就是最长回文子串。   
因此有如下的方法，使用p[i]表示以下标i为中心的最长回文子串半径：

笨方法的代码示例：

```

String s; // s为构造后的新串

int iMax = 0;

for(int i = 0; i < s.length(); ++i) {

  while(s.charAt(i - p[i]) == s.charAt(i + p[i]) && i + 1 - p[i] >=0 && i + p[i] <= s.length())
    ++p[i];

  if(p[i] > p[iMax])
    iMax = i;
}

//[iMax - (p[iMax] - 1), iMax + (p[iMax] - 1)] 除去特殊字符即为最长回文串

```

##### 更好的方法--Manacher #####

思路：

但其实我们有更好的方法，因为上述方法有很多重复的计算。利用回文的性质，回文关于中心对称的两个点，以这两个点为中心的回文子串，在对称中心回文串的范围内应该有相同的表现，可以根据此改进方法如下：

```
// p[iRMax] + iRMax > i && i > iRMax，那么
p[i] = Math.min(p[iRMax - (i - iRMax)],iRMax + p[iRMax] - i);
//p[i]最终的值必定大于上面的值，这相当于给p[i]一个初值
```

对构造串求最长回文串，iRMax记录当前向右扫描最远的最长回文子串中心下标。

代码示例:

```
String s; // s为构造后的新串，可以在首尾增加哨兵检查越界，如1234 -> ^1#2#3#4#
int iRMax = 0;
int i = 0;
p[i++] = 1;

for(; i < s.length(); ++i) {
  int r;
  if(i < iRMax + p[iRMax]) {
    p[i] = Math.min(p[iRMax - (i - iRMax)],iRMax + p[iRMax] - i);
  }
  
  while(s.charAt(i - p[i]) == s.charAt(i + p[i])) //利用首尾哨兵检查越界
    ++p[i];

  if(i + p[i] > p[iRMax])
    iRMax = i;
}

//[iMax - (p[iMax] - 1), iMax + (p[iMax] - 1)] 找到最大的半径p[iMax]，除去特殊字符即为最长回文串

```