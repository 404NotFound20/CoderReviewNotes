# 摩尔投票 #

### 典型问题 ###

假设一个数组中一定存在一个元素，它的出现频率大于1/2，找到此元素

思路：

每次从数组中选择两个不同的元素删掉，直到数组中没有不同的元素，剩下的元素值就为出现频率大于1/2的（这个结论的前提就是必定存在出现频率大于1/2的元素）。   
具体算法可以遍历一遍数组，使用一个变量记录当前扫描的值，在使用一个整型变量记录这个元素出现的次数，每当遇到与其相同的元素时，次数加一，遇到不同的元素时，次数减一，当次数为0时，重新记录元素，示例代码如下：

代码示例：

```
int moore(int arr[]) {
  int count = 0;
  int item;

  foreach(int a : arr) {
    if(count == 0) {
      item = a;
      ++count;
    }
    else {
      count = (item == a) ? count + 1 ： count - 1;
    }
  }

  return item;
}
```

### 问题拓展一 ###

上个问题要求必须存在出现频率大于1/2的元素，如果可能不存在这样的元素时，怎么求解？

思路:

仍然使用典型问题的求解方法，不同的是，上面的求解方法可能返回空，也可能返回一个元素。当返回空时，显然不存在所求元素，当返回一个元素时，还要对这个元素进行验证，即遍历一遍数组，统计这个元素的出现频率，根据频率决定最终返回空或该元素。

### 问题拓展二 ###

现在的问题是，求解一个数组内出现频率大于1/3的元素。

思路：

我们可以知道，频率大于1/3的元素最多为2个。可以将数组的元素每3个不同的一组删除，直到数组中不存在3个不同的元素，然后把得到的每个元素再去原数组统计一次出现频率，验证是否出现频率大于1/3。对照典型问题的求解方法，我们可以遍历一遍数组，使用两个变量来记录当前扫描到两个不同的元素，并用两个整型变量分别统计次数，当统计次数都大于0，且扫描到与这两个元素都不同时，统计次数分别减一，当有统计次数为零时，重新统计元素。最后对统计次数大于0的元素的出现频率进行验证。

代码示例：

```
int moore(int arr[]) {
  int n;
  int nCount = 0;
  int m;
  int mCount = 0;

  foreach(int a : arr) {
    if(nCount == 0) {
      n = a;
      ++nCount;
    }
    else if(mCount == 0) {
      m = a;
      ++mCount;
    }
    else if(m == a)
      ++mCount;
    else if(n == a)
      ++nCount;
    else {
      --mCount;
      --nCount;
    }
  }

  //遍历数组，验证m,n的出现频率
}
```