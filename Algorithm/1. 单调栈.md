# 单调栈 #

一般有单调递减栈，单调递增栈，单调不减栈，单调不增栈。通过单调栈很容易找出一个数组的最长单调区间或者局部单调序列。

### 典型问题 ###

L要和MM结婚了。在两人的走进礼堂的红地毯两侧，需要摆一些装饰用的花篮，有一些不同高度的花篮，现在这些花篮被L依照自己的美学观念编号为S1,S2,S3…Sn（两侧的花篮高度一样）。可L的MM对这些花篮的摆放方式有不同的看法，她觉得满足以下条件的花篮摆放才是最好的。    
如果对于区间[Si,Sj](1<=i<j<=n)中任意的花篮都比Si高且比Sj低，那么这个区间称为一个美学区间。对于所有的美学区间，其长度（定义为j-i）都必须小于等于k，如果有长度大于k的美学区间，MM就会不高兴，L就会有麻烦。

输入一个整数序列和一个整数k，输出最大的美学区间长度，不存在输出0。

思路：建立一个单调递增栈，当栈空时直接入栈，当入栈元素大于栈底时按照单调递增确定是否入栈，当入栈元素小于栈底时，记录栈顶下标减去栈底下标为一个美学区间，然后全部出栈，之前栈顶元素的下一元素入栈。

代码示例：

```

public int getLengthestBeautifulSection(int[] high) {
       Stack<Integer> stack = new Stack<>();

        int i = 0;
        int base = 0;
        int ret = 0;

        while (i < high.length) {
            if(stack.isEmpty()) {
                stack.push(i);
                base = i++;
                continue;
            }

            int top = stack.peek();

            if(high[i] > high[top]) {
                stack.push(i);
            }
            else if(high[i] < high[base] || i + 1 == high.length) { // 后面这个或条件很重要
                ret = top - base > ret ? top - base : ret;
                stack.removeAllElements();
                i = top;
            }
            ++i;

        }

        return ret;
}

```