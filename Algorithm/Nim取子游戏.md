# Nim取子游戏 #

通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，两个人交替取走石子，合法的取法是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。假设两个人每次都采用最优解。

思路：

考虑只有1堆石子，则先手必胜。
考虑2堆数量相同的石子，则先手必败。不论先手取多少石子，后手只需每次取相同数量的石子维持2堆石子数量相同即可获胜。
考虑2堆数量不同的石子，可以取走石子使得取走后两堆石子数量相同，则此种情况先手必胜。
考虑3堆数量相同的石子，先手必胜

由于任意整数都有对应的二进制数，所以可以把任意数量的一堆石子，分成若干个2的幂次方数量的子堆。现在分析每2个相同次幂的2次方子堆必定是先手必败的，假设所有堆的2的幂次方子堆，都为偶数个，也就是成对出现的，那么此种情形必定是先手必败的，后手只需在与先手对应的2次方子堆取相同数量的石子即可获胜；假如存在奇数个2的幂次方子堆，则先手总能找到一种取法使得所有2的幂次方堆为偶数个，即先手必胜。

转换为数学关系就是：

1. 所有堆数量异或为0 -> 所有堆的2的幂次方子堆数都为偶数个 -> 先手必败
2. 所有堆数量异或不为0 -> 存在奇数个2的幂次方子堆数 -> 先手必胜

那么，当先手必胜时如何取子呢，很简单，找到一个堆（这样的堆一定存在，下面有证明）的数量大于其他所有堆的异或值，取走石子使得此堆的数量和其他所有堆的异或值相等即可。

**证明：所有堆数量异或不为0时，必然存在一个堆的石子数量大于其他所有堆的异或值**

2的最高次幂子堆若为奇数个，则其中任意一个子堆所在的堆数量都大于其他堆的异或，若为偶数个则比较2的次高次幂子堆，若次高次幂子堆还为偶数个，则继续比较次次高次幂子堆，总存在一个奇数子堆，否则所有堆石子数量的异或值必为0，得证。

```
/**
 * 若干堆石子的当前最优取法
 *
 * @param a 数组表示当前每个堆的石子数
 * @return 返回一个Pair，第一个值表示应取的堆下标，第二个表示取走石子数量，返回null表示必败
 */

public Pair<Integer,Integer> getNext(int[] a) {
    int xor = a[0];
    for(int i = 1; i < a.length; ++i)
        xor ^= a[i];

    if(xor == 0)
        return null;

    for(int i = 0; i < a.length; ++i){
        int temp = xor ^ a[i];
        if(a[i] >= temp) {
            return new Pair<>(i,a[i] - temp);
        }
    }

    return null;
}

```