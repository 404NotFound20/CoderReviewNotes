# C++ 基础 #

## 引言

无论什么时候接触 C++，都应该视 C++ 为一个语言联邦（这个概念来源于《Effective C++》），这个联邦的主要子语言包括：

* **C** —— C++ 是以 C 语言为基础。区块、语句、预处理器、内置数据类型、数组和指针等都来源于 C。
* **Object-Oriented C++** —— 这部分也是 C with classes 的诉求：classes（包括构造函数和析构函数）、封装、继承、多态、虚函数......等等面向对象的实施。
* **Template C++** —— 泛型编程，Template 相关考虑和设计已经弥漫到了整个 C++。
* **STL** —— STL 是个 Template 程序库。它对容器，迭代器，算法以及函数对象的规约有者极佳的紧密配合与协调。

记住这几个子语言，当从一个子语言切换到另一个子语言，导致编程守则的转换是十分自然的。本片文档的介绍也主要按照这四个子语言顺序来记录的。

## 1. C++ 与 C 的交叉基础

### 1.1 预处理

预处理（或称预编译）是指在进行编译的第一遍扫描（词法扫描和语法分析）之前所作的工作。预处理指令指示在程序正式编译前就由编译器进行的操作，可放在程序中任何位置。 C++ 完全继承了 C 的预处理功能。

**文件包含**

```cpp
// 直接在包含文件目录中去查找(包含目录是由用户在设置环境时设置的include目录)
#include <文件名>
// 首先在当前源文件目录中查找，若未找到才到包含目录中去查找
#include "文件名"
```

**条件编译**

```cpp
//只有定义了宏名才编译 ifdef 定义内的语句
#ifdef 宏名
//[#else]
#endif

//只有未定义宏名才编译 ifndef 定义内的语句
#ifndef 宏名
//[#else]
#endif

//只有常量表达式非 0 才编译 if 定义内的语句
#if 常量表达式
//[#else]
#endif
```

**宏定义**

在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代换，这称为宏替换或宏展开。 

使用方法如下：

```cpp
// #defind 宏名 字符串
#define MAX 100

// #defind 宏名(参数) 字符串
#define MAX(A,B) ((A) > (B) ? (A) : (B))

// 字符串化，使用 # 将字符串用双引号包围起来
// 以下两种写法作用相同
#define MAKESTR(name) #name 
#define MAKESTR(name) "name"

// 字符化，使用 #@ 将字符用单引号包围起来
// 以下两种写法作用相同
#define MAKECHAR(C) #@C 
#define MAKECHAR(C) `C`
```

宏定义的展开与先后顺序无关，预处理器是这样对宏替换的先将所有的宏定义收集起来，然后处理源代码，发现一个宏定义符就立即替换。 

而且，宏是预处理时的完全替换，没有任何语义的考虑，所以要使用括号区分歧义，否则可能就会逻辑错误。如

```cpp
#define ADD(A,B) A + B
ADD(1,2) * ADD(3,4)	//结果为11，因为宏展开为 1 + 2 * 3 + 4
```

ANSI 标准指定了 5 个内置宏定义，主要为调试使用

* \_\_LINE\_\_：当前源代码行号；
* \_\_FILE\_\_：当前源文件名；
* \_\_DATE\_\_：当前的编译日期
* \_\_TIME\_\_：当前编译时间；
* \_\_STDC\_\_：当要求程序严格遵循 ANSI C 标准时值为 1

### 1.2 头文件

最新 C++ 的标准头文件都是没有扩展名的，如 `#include <iostream>`；

C 的标准文件在 C++ 中的头文件都被转为c开头，如 `#include <cmath>`

### 1.3 注释

C++ 的标准注释是双斜杠 `//`，同时也兼容了 C 的注释 `/* */`

> C99 标准也添加了 `//` 注释

## 2. 变量

### 2.1 内建类型

变量的定义一般形式为 `变量类型 变量名`。

**所有内建类型**

* [unsigned] char —— 1个字节大小
* wchar_t —— 宽字符， 2个字节大小
* char16_t —— Unicode 字符，2个字节大小
* char32_t —— Unicode 字符，3个字节大小
* [unsigned] short —— 至少 2 字节大小
* [unsigned] int —— 至少和 short 一样大
* [unsigned] long —— 至少 4 字节大小，且至少和 int 一样大
* [unsigned] long long —— 至少 8 字节大小，C11新定义
* float —— 一般为 4 字节大小，浮点型的数据可以用 1.2e+10 表示，1位符号位，8位指数位，23 + 1位有效数字位
* double —— 一般为 8 字节大小，1位符号位，11位指数位，52 + 1位有效数字位
* bool —— 未定义最先尺寸，一般为 1 字节大小

### 2.2 数组 & 向量 & 字符串 

**（一）数组**

数组的一维大小可以在初始化时推断给出，高于一维的数组必须由常量指定。

```cpp
// 声明时必须给定数组大小
int arr[10];

//一维大小也可由推断得出。等号可不写
int arr[]{1,2};

//后面没有大括号的声明将不会初始化
//部分初始化，未初始化的元素将设为 0
int arr1[10];	// arr1[1] 未知，arr1[9] 未知
int arr2[10]{1, 2}; // arr2[1] 为 2，arr2[9] 为 0 
int arr2[][10]{{1,2},{2}};
```

**（二）向量 vector**

原生数组支持者静态大小，STL 提供了动态数组 vector，支持运行时指定大小和动态扩展。

vector 是一个模板类，大部分初始化方式类似数组：

```cpp
vector<int> v1; // 默认初始化
vector<int> v2{1, 2}; // 列表初始化
vector<int> v2(10); // 初始 10 个元素，每个元素默认初始化
vector<int> v3(10, 3); // 初始 10 个元素，每个元素初始化为 3
```

**二维动态数组的声明方式**

```cpp
// m, n 为整形变量，指定了二维动态数组的大小
// 第一种
int ** arr = new int *[m];
for(int i = 0; i < m; ++i)
    arr[i] = new int[n];

// 第二种
vector<vector<int>> arr(m, vector<int>(n));

// 当二维可以设为常数大小时
int (* arr)[5] = new int[n][5];
```

**（三）字符串**

```cpp
// C 风格定义字符串，以下两种定义相同，需要注意的是，若 str 不指定 `\0`，将无法预料字符串的结尾
char str1[] = "abc";
char str2[] = {'a', 'b', 'c', '\0'};

// C++ 新增的 string 类，string 内部维护了一个字符串数组，并动态扩容
string s = str1;
```

string 重载了很多操作符，使得字符串连接和复制非常方便，无需使用 strcat() 和 strcpy()。使用 s.size() 即可获得字符串大小，相当于 strlen(s.c_str())。

### 2.4 迭代器介绍

vector 和 string 除了下标访问外还支持迭代器访问，迭代器类型一般都为`{容器具体类型}::iterator`，可以通过对象的 begin() 方法获取指向第一个元素的迭代器，end() 类似 EOF ，称之为尾后迭代器。

**标准迭代器支持的方法**

* `* iter` —— 获取 iter 指向元素
* `iter->item` —— 解引用 iter 并获取元素 item，相当于 `(*iter).item`。
* `++iter / --iter` —— 自增或自减，移动迭代器指向
* `iter1 == iter2` —— 判断迭代器相等
* `iter1 != iter2` —— 判断迭代器不等

> string 和 vector 的迭代器还支持`iter +/-/+=/-=/>/</<=/<= n` 和 `iter2 - iter1` 操作。

**迭代器类型**

`{容器具体类型}::iterator` 获取的是可读可写的爹大气；

`{容器具体类型}::const_iterator` 获取的是只读的底层 const 迭代器。

当容器具体元素类型是常量的化会返回 const_iterator，否则返回 iterator。

**静态数组的迭代器**

标准库提供了 begin() 和 end() 函数，用来获取的数组的第一个元素指针，和尾后指针。

### 2.5 结构体 & 联合体 & 枚举

**结构体**

```cpp
struct MyStruct {
    int a; //成员变量
    char b;
    
    void print() { //成员函数
        //...
    }
}; //声明语句，需要结束结构体声明

// C 中使用时，必须使用 struct 关键字
struct MyStruct ms1;
// C++ 中可以省略 struct 关键字
MyStruct ms2;

//结构体的初始化方式
//使用大括号的方式给结构体成员赋值，按照定义的顺序进行
ms2 = {1, 'a'}; 
//也可使用另一个结构体去初始化
MyStruct ms3 = ms2；
```

可以看的出，C++ 的结构体在 C 的基础上进行了扩展，且行为和类很像。

结构体的大小等于所有成员的大小之和加上8字节对齐填充的大小。

> 结构体还可以指定每个成员的位长度，如下
>
> ```cpp
> struct BitStruct {
>     int SN: 4;// SN 占 4 位
>     int: 4;// 跳过 4 位
>     bool T: 1; // T 使用 1 位
> }
> 
> //赋值和使用时可以像正常类型一样使用，但在赋值时只低位匹配的位数。
> ```

**联合体**

```cpp
union MyStruct {
    int a; //成员变量
    
    void print() { //成员函数
        //...
    }
};
```

联合体的大小等于所有成员的中的最大的成员大小加上8字节对齐填充的大小。

**枚举**

```cpp
enum E {a,b,c} //默认 a b c 整数值为 0 1 2
enum E2 {a = 10, b , c} //这时 a b c 的整数值为 10 11 12
enum E3 {a, b = 0, c} //这时 a b c 的整数值为 0 0 1，枚举的整数值允许重复
```

将枚举当作整数值计算不会有任何问题，但是将一个整数值赋给一个枚举是需要考虑的。所以枚举也没有自增操作。

通常将一个整形值强转为枚举值，在枚举范围内是被允许的，即便这个枚举值没有对应的元素。将一个整形值枚举的取值范围由枚举元素的最大整数值和最小整数值决定，范围上界为大于最大整数值的最小 2 次幂减 1，对于范围下界，当最小整数值大于等于 0 是，下界为0，否则，与寻找上界方式相同，但加上负号。如最大整数值 6，最小整数值为 -6，对应的上下界为 [7,-7]。对于有些编译器，可能并没有限制枚举范围。

### 2.6 复合类型

**（一）指针类型**

使用任意类型和 * 组合起来表示一个类型的指针类型，如 `int * p`，表示 p 是整型指针。

指针类型在声明时需要注意以下两点。

const 遇 * 截断修饰（也可以认为是优先级低，这里只是为了方便理解而定义）——意思就是当 const 遇到  * 时会把 * 和其之后的所有声明段看成整体来修饰。如：
```cpp
int a;
// 以下两种写法相同，const 修饰 *p，表示 *p 不能进行赋值操作（a 的值仍可改变，只是不能通过 *p）
int const * p = &a;
const int * p = &a;
// 下面的 const 修饰 p，表示 p 不能进行赋值，即 p 不能指向其他变量了
int * const p = &a;
```
\* 不能在声明时向后传递，如 `int * a, b;` ，a 是指针，b是整形。

**（二）引用类型**

关于左值和右值可以参考表达式章节

**左值引用类型**

使用任意类型和 & 组合起来表示一个类型的左值引用类型，如 `int & p`，表示 p 是引用类型，引用类型在声明时必须初始化。引用类型变量相当于原变量的一个别名，用法和原变量完全一样，因为它们的地址完全相同。

一旦引用初始化后，就不能成为其他变量的引用了。所以 & 和 const 的没有顺序上的影响，无论 const 在什么位置，都表示引用变量不能进行赋值操作。

& 也不能在声明时向后传递。

当引用类型作为返回类型时需要注意不能返回一个临时变量的引用。

**右值引用类型**

使用任意类型和 && 组合起来表示一个类型的右值引用类型。右值引用可以用来接住右值实参，也可以用来接住一个右值返回值。从而避免拷贝构造函数的调用。

### 2.7 变量

**变量名的要求**

- 由数字、字母和下划线组成，但不能以数字开头
- 双下划线开头和单下划线和大写开头的名称一般作为保留名称，留给编译器等使用
- C++ 没有长度要求，C 则最多智能识别 63 个字符，超过会阶段

**变量作用域**

当变量被定义在一个花括号内时，它的作用域就是它最接近（最内部）的花括号块，这样的变量一般称之位局部变量。

当变量不位于花括号之内时，也就一定不位于函数内，这样的变量称之为全局变量，在当前文件的所有函数内部都有效。当与局部变量重名时，可以使用 "双冒号+全局变量名" 显示访问全局变量。

### 2.8 变量初始化

**声明与定义**

声明：告知编译器有一个某个类型的变量

定义：将对象实体值和变量关联，即赋值

通过 extern 来声明一个变量，来引入一个外部文件的全局变量，如：

```cpp
extern int i; // 声明

//可以声明并定义
int k = 2;

//但是对 extern 赋值，将退化为定义
extern int y = 3; // 定义
```

**变量初始化** 

* 值初始化，如：`int a = 1`

* 构造初始化，使用圆括号的方式调用构造函数，支持所有类型：`int a(2)`；

* 列表初始，支持数组，动态数组vector，字符串，结构体。列表初始化若存在精度丢失的风险将会报错，如将 浮点数赋给整形。

  ```cpp
  //数组，列表中未指定的用 0 值初始化
  int arr[10]{1,1};
  vector<int> arr2{1,2,3};
  vector<int> arr3(10,2); // 构造初始化为 10 个大小数字，每个元素被初始化为 2，
  						// 当第 2 个参数为结构体或类时，会调用拷贝构造函数
  
  //字符串
  char str[] = "hi"; //自动添加 '\0'
  
  // 结构体
  struct Node {
      int a, b;
      char c;
  };
  
  Node n{1,2,'a'};//按照成员变量顺序赋值
  ```

**默认初始化**

对于内建类型来说，全局变量将被默认初始化为0，局部变量将不初始化。

对于结构体或类对象来说，将自己定义是否默认初始化。

局部静态变量会在第一被执行到时初始化，如果没有指定初始化值将会执行默认初始化。

**字面量值**

* 十进制整型——1
* 十六进制整型——0x10 == 16
* 八进制整型——010 == 8
* 浮点型 —— 3.14
* 浮点型科学表示 —— 3.14E0
* 字符 —— 'A'
* 转义字符 —— '\n\r\t\'；16 进制表示ascii 字符 —— '\x0f'；8 进制表示 ascii 字符 ——'\12'
* 字符串 —— “abc”；

> 整形字面量后缀
>
> u/U —— unsigned；l/L —— long；ll/LL —— long long
>
> 浮点型字面量后缀
>
> f/F —— float；d/D —— double
>
> 字符字面量前缀
>
> u —— char16_t；U —— char32_t；L —— wchar_t
>
> 字符串字面前缀
>
> u8 —— utf8 字符串

### 2.10 指针和引用

**指针 —— ***

有两个作用：

- 在类型符后使用，表示是指针类型。具体查阅后面复合类型的章节。
- 在变量前使用，表示解引用。

> **数组指针**
>
> 首先看下数组的指针和指针的数组表示方法：`type (* variable_name)[...]`。
>
> 对于一维数组指针就是 `int (* p)` 去掉括号即 `int * p`；因为 p 之后是空白，括号打开不影响语义。
>
> 对于二维数组指针就是 `int (* p)[10]` ，必须指定第二维大小，高维数组大小必须指定各维度大小，第一维除外，也无法指定。同时括号不能少，打开括号 p 会先和后面的整体结合，而使 p 成为一个数组名，元素类型为` int *`。
>
> 下面是具体的示例和解读：
>
> ```cpp
> //int * 表示一个整形指针，直线一个 int 大小的区域
> //int (*)[5] 表示一个数组指针，该指针指向一块 int[5] 大小的区域
> //int (*)[5][5] 也是一个数组指针，该指针指向一块 int[5][5] 大小的区域
> int a[5]; 一维数组，数组名作指针时长度为一个 int 大小，即 int * 型
> int b[5][5]; 二维数组，数组名作指针时长度为 int[5] 大小，即 int (*)[5] 型
> int c[5][5][5]; 三维数组，数组名作指针时长度为 int[5][5] 大小，即 int (*)[5][5] 型
> 
> // 数组指针变量
> int (* pa) = a;// int (* pa) 也即 int * pa
> int (* pb)[5] = b;// 可以理解为 (* pb) == b[0] == (* b)
> int (* pc)[5][5] = c;
> 
> // 根据以上我们能够知道下面的赋值是错误的
> int ** pb2 = b; // 编译出错，类型不匹配，pb2 是一个 int 的二级指针，它的长度为一个 int * 大小
> 
> // 对于形参，数组参数的第一维 p[] 就相当于 (* p)
> void fa(int pa[]); // 相当于 fa(int (* pa));
> fa(a); // 调用正确
> void fb(int pb[][5]); // 相当于 fa(int (* pb)[5]);
> fb(b); // 调用正确
> void fc(int pc[][5][5]); // 相当于 fa(int (* pc)[5][5]);
> fc(c); // 调用正确
> 
> // 我们现在应该也能判断除下面的调用是不正确的
> void f(int * p[]); // 相当于 f(int * (* p));
> f(b);// 编译错误，类型不匹配
> 
> //以下是一个稍复杂的数组指针例子
> int ** (*b)[2]; // b 是一个二维数组指针，每个数组元素是 int ** 类型
> ```
>
> **函数指针**
>
> 函数指针的表示方法 `return_type (* variable_name)(type1 param1, type2 param2, ...)`。
>
> 其中括号也不能省，打开括号就不是指针定义了。因为 variable_name 会首先和参数列表结合，使得上式变成一个返回类型为 `return_type *` 的函数声明。
>
> 来看具体的示例和解读：
>
> ```cpp
> // 先声明一个函数
> void a();
> 
> // 一个合法的函数指针
> void (*pa)() = a;
> 
> // 一个错误的定义
> void * pa2() = a; // 左值不是一个变量，而是一个函数声明
> 
> //需要注意的使，C++ 为了更广泛的兼容，以下两种函数访问方式都正确
> (* pa)();
> pa();
> ```
>
> **两个比较复杂的指针使用**
>
> 第一个：
>
> ```cpp
> int   *(*p(int))[3];
> ```
>
> ()的优先级最高，因此p先与()结合，说明p首先是个函数，
>
> 再与括号内的int结合，说明函数的参数为一个int,
>
> 再与p前面的*结合，说明函数的返回值为一个指针A，
>
> 再与后面的[]结合，说明该指针A指向的内容是一个数组，
>
> 再与第一个*结合，说明数组里面的元素是指针B，
>
> 再与前面的int结合，说明指针B指向的内容是一个int。
>
> 第二个：
>
> ```cpp
> int (*(*p)(int))(int);
> ```
>
> ()的优先级最高，因此p先与*结合，说明p首先是个指针A，
>
> 再与后面()结合，说明该指针A指向的内容是一个函数A，
>
> 再与括号中的int结合，说明该函数的参数是一个int,
>
> 再与(*p)前面的*结合，说明该函数的返回值是一个指针B，
>
> 再与最后面的()结合，说明该指针B指向的内容提要是一个函数B，
>
> 再与括号中的int结合，说明该函数B的参数是一个int，
>
> 再与前面的float结合，说明函数B的返回值为float。

**引用——&**

& 有三个作用：

- 在类型符后使用，表示引用类型。具体查阅后面复合类型的章节
- 在变量前使用，表示取地址。
- 在两个整形变量之间使用，表示按位与。

> **数组引用**
>
> 数组引用和同数组指针定义类似：`type (& variable_name)[...]`。如:
>
> ```cpp
> int a[5];
> int b[5][5];
> 
> //数组引用变量定义，必须指定大小，包括一维
> int (& ra)[5] = a;
> int (& rb)[5][5] = b;
> ```
>
> 数组引用的语义和数组名的语义完全相同，而数组指针的语义仅仅是一个指针的语义。

### 2.11 const & constexpr

const 修饰的变量不能进行赋值操作，需要注意的是当 const 遇到 * 时会修饰 * 和后面整个声明。

不能把一个 const 指针、引用或变量赋给一个非 const 指针或引用。

以下是 const 使用举例：

```cpp
//普通类型的 const
const int a = 1; // 不能对 a 赋值

// const 与指针
const int *b = 1; //底层const，const 修饰的变量其指向内容不能赋值
int * const c = 2; //顶层const，const 修饰的变量本身不能赋值

// const 与引用
const int &d = a; //d 不能进行赋值行为
```

> 形参指针应该尽可能的使用 const，好处是：
>
> - 可以避免以外改变
> - const 可以接收 const 和非 const，而非 const 不能接收 const。

常量表达式是指编译器期间就可以确定值的表达式。字面量就是常量表达式，用常量表达式初始化的 const 对象也是常量表达式，如：

```cpp
const int a = 2; // 常量表达式
const int b = a + 1; // 常量表达式
const int d = size(); // 只有当size() 返回常量表达式才是常量表达式
```

可以看出，const 修饰的表达并不总是常量表达式，C11 增加了 constexpr 关键字来声明一个常量表达式，所以 constexpr 是忽略星号的，其修饰的变量总是一个顶层 const，如：

```cpp
constexpr  int a = 2; // 正确
constexpr  int b = a + 1; // 正确
constexpr  int d = size(); // 只有当size() 返回常量表达式才是正确，否则编译出错
```

constexpr 表达式必须要在编译期间计算出值，所以必须限定其类型，不能够太复杂。目前只有内建类型，指针和引用类型可以声明为 constexpr。并且 constexpr 和 const 可以共用，如：

```cpp
constexpr int c = 2;
constexpr const int * a = &c; // a 不能赋值，*a 也不能赋值
```

***注意：***常量表达式可以在编译期间计算出值，也会在编译期间把相应常量直接用值替换。所以，即便可以通过其他方式改变常量表达式内存的值，也不能改变该常量使用位置的值。

### 2.12 类型别名 & auto & decltype

**类型别名**

C 风格别名：typedef char * pchar;

C11 新标准：using pchar = char *;

区别在于 using 可以指定模板的别名，而 typedef 不支持。

需要注意的是，别名并不是可以完全原位替换的，如：

```cpp
using pint = int *;
int a = 1;
const pint b = &a;//顶层const
const int * c = &a;//底层const
```

**auto**

C++ 支持通过表达式来自定义推断定义，使用 auto 关键字代替类型即可。

但是并不是编译器始终可以推断出我们想要的类型，auto 会忽略掉顶层const，如：

```cpp
const int a = 1;
auto b = a; // b 只是一个普通变量，可以赋值
const auto c = a;// 这样可以使 c 推断为 const int； 
```

**decltype**

decltype 可以不计算表达式只获取表达式的类型，这个获取的类型一般 auto 推断相同。使用示例：

```cpp
decltype(size()) a;// a 的类型为 size() 返回类型
auto b = size();// 类型与 a 完全相同

//但在推断数组的时候会有不同
int a[10];
auto b(a); //b 是一个 int * 的指针，sizeof(b)== 8
decltype(a) c;// c 是一个数组名，sizeof(a)== 40
```

## 3. 表达式和语句

### 3.1 左值 & 纯右值 & 将亡值

下图中，glvalue 为范左值，rvalue 为右值，lvalue 为左值，xvalue 为将亡值，prvalue 为右值。

![20170228002047056](CppBasics.assets/20170228002047056.png)

通俗来说，可以放在等号左边的值称为左值，只能放在等号右边的值称为右值。等号左边就是一般意义上我们可以赋值的变量名。但是以上的定义只在 C 语言中是正确，在 C++ 中有些左值并不能放在等号左边。所以 C++ 中左值更准确的定义为**可以取地址的表达式为左值**，否则右值。把可以接住右值的右值引用值称之为将亡值。下面给出准确的定义和示例：

* lvalue —— 可以取地址的的所有表达式。如：

  ```cpp
  //具名变量
  int a;
  //返回左值引用的函数调用，
  A & f(A & a) {return a}; f(a);
  //前置自增或自减
  ++i,--i;
  //各种赋值表达式
  a = b;
  a += b;
  //解引用表达式
  (*p) = b;
  //字符串字面量
  cout << &"abc";
  ```

* prvalue —— 非字符串字面量表达式，不具名（编译前）的临时变量。如：

  ```cpp
  //非字符串字面量
  1，'a'；
  //返回非引用类型的函数调用
  A f(A a) {return a};f(a);
  //后置自增或自减
  i++, i--;
  //算术/逻辑/比较表达式
  a+b, a&b, a<<b;
  a&&b, a||b, ~a;
  a==b, a>=b, a <b ;
  //取地址表达式
  &a;
  ```

* xvalue —— 将亡值，用右值引用表达式引用的值。如：

  ```cpp
  //直接接住右值, a 为右值引用变量，但是是一个左值
  A && a = f();
  //左值转换为右值
  std::move(), tsatic_cast<X&&>(x);
  ```

### 3.2  移动语义 & 完美转发 & 通用引用

**右值引用的应用 —— 转移构造函数（移动语义）**

假如有下面的调用：

```cpp
A f(A a) {
    return a;
}

int main() {
    A aa;
    A bb = f(aa);
}
```

bb 赋值语句的执行过程：首选，实参 aa 拷贝构造形参 a；返回时形参 a 拷贝构造临时变量；最后临时变量拷贝构造 bb。bb 赋值的伪编译代码：

```cpp
A temp;//仅分配空间，不进行任何构造
f(aa, temp);// 函数变为 A f(A a, A & temp); 
a(aa); // 拷贝构造
temp(a); // 拷贝构造
bb(temp); // 拷贝构造
```

对于 temp(a) 的拷贝构造，当 a 成为非引用返回值时，由于函数执行完毕，形参 a 就被视为右值，所以这时若 A 存在转移构造函数时就可以优化为浅拷贝。而这时如果用 `A && bb = f(aa);` 接住临时变量，就又可以减少一次拷贝。这个过程就是右值引用对程序的优化（可以减少一次拷贝，且把一次深拷贝转为浅拷贝）。

可以看出，转移构造函数相当于把一个对象的内容移动到另一个对象中去，所以把这样的语义称之为引用语义

**完美转发**

使用 `std::forward<T>(t)` 可以保持形参 t 原有的实参类型将其转发出去。

```cpp
template<typename T>
void relay(T && t) { // t 接收一个右值，但自身是左值
    cout << "in relay " << endl;
    func(std::forward<T>(t)); // 将 t 作为右值转发除去
}
```

**通用引用**

之所以能完美转发，是因为通用引用的存在，通用引用可以绑定任何类型的变量。通用引用只存在两种定义：

* auto && a = f()
* f(T && a); 函数模板

上述两种定义的共同点是 a 的类型需要推断而来，这个推断的规则就是**引用折叠**：

```cpp
T & & => T&
T && & => T&
T & && => T&
T && && => T&&
```

对于 `T && a` 来说只用看第2条和第4条规则，就是传进来的如果是左值引用那就是左值引用，如果是右值引用那就是右值引用。所以 `std::forward<T>(t)`  就可以逆推出实参类型，从而进行类转为相应的类型。

所以只有在通用引用中才需要完美转发，非通用引用的类型都是确定的。

但是注意，这个合成规则用户是不允许使用的，只有编译器才能够使用这种合成规则。这就是为什么上面的通用引用当中有一条要求是类型必须可以自动推导。

### 3.3 优先级 & 结合律 & 求值顺序

复合表达式的值的运算顺序由优先级和结合律决定。

**优先级**：运算符的优先级高，那么该运算符的操作数会优先计算结果。如 `1 + 2 *3` 先算乘法。

运算符优先级：自增成员解地址，算位关逻条赋逗；

**结合律**：当运算符优先级相同的情况下，结合律决定哪个运算符优先计算结果。如 `3 - 2 - 1`从左往右算。

右结合运算符：单条赋，移位运算符除外。其他都是左结合。

**求值顺序：**优先级和结合律与运算对象求值顺序（注意运算顺序和求值顺序不是一个概念）没有任何关系。如：

```cpp
int a = f1() + f2() * f3() + f4();
```

上述4个函数的求值顺序是不可预知的，依赖于具体的编译器。优先级和结合律只是决定有了值以后的计算顺序。

### 3.4 运算符

作用域运算符：`::` 。

成员运算符：`.`、`->` 、`[]`（下标）、`()` （函数调用或类型构造）。

自增运算符：`++`、`--` 。

地址运算符：`*`（解引用）、`&`（取地址）。

功能运算符：`sizeof` 、`new`、`delete`。

以上为大部分一元运算符。

算术运算符：`+`（正）、`-`（负）、`*`（乘）、`/`（除）、`%`（取余）、`+`（加）、`-`（减）。

位运算符：`~`（按位反）、`<<`（左移）、`>>`（右移）、`&`（按位与）、`|`（按位或）、`^`（按位异或）。

关系运算符：`<`（小于）、`<=`（小于等于）、`>`（大于）、`>=`（大于等于）、`==`（等于）、`!=`（不等）。

逻辑运算符：`!`（逻辑非）、`&&`（逻辑与）、`||`（逻辑或）。

条件运算符：`? :`

赋值运算符：`=`。扩展 `+=`、`-=`、`*=`、`/=`、`%=`、`>>=`、`<<=`、`&=`、`|=`、`^=`、

逗号运算符：`,`。表达式值为最后一个逗号之后的。

以上运算符从上到下优先级逐渐降低（一元运算符除外），同一行左边的运算符优先大于等于右边。

**sizeof 运算符**

sizeof 运算符返回类型或变量所占内存字节数的大小，特别需要注意的是，`sizeof 数组名` 值为整个数组的大小。

### 3.5 类型转换

有些时候当类型不严格匹配时会发生隐式类型转换，这些转换可以由编译器自动完成。

**隐式转换的时机**

* 大多数表达式中，比 int 类型小的整形会首先提升为 int
* 条件表达式，非布尔值转化为布尔值
* 赋值语句或函数调用
* 算术运算或关系运算

**隐式类型转换**

- 数值型 -> 布尔型，非 0 转为 true

- 布尔型 -> 数值型，true 转为 1

- 浮点 -> 整形，忽略小数点后的值

- 整形 -> 浮点，小数点后都为 0

- 无符号数赋值超范围，高出的位数截断

- 符号数超出范围，结果标准未给出定义

- 有符号转无符号，位模式不变

- const 转换规则：

  -  const 类型可以接收 const 类型和非 const 类型

  - 非 const 不能接收 const 类型

  - auto 会丢失顶层 const 语义

  - `const T &&` 和 ` T &&` 只能使用`T 类型的右值` 赋值 ;

    `const T &` 可以使用 `const T && `、` T &&` 、`const T &` 以及 `T 类型的左值 `赋值 ;

    `T &` 只能使用 `T 类型的左值` 赋值 ;

    `T` 可以接收 `T 类型的左右值` 。

**强制类型转换**

C 风格：`(int) 1.2`，C++ 中仍可使用这种风格

C++ 新式风格 `int(1.2)`，更像是函数调用

此外c++还有四种转换形式：

* `dynamic_cast<T>` —— 动态识别类型转换

* `static_cast<T>` —— 除了不可转换掉底层 const，其他都可以

  ```cpp
  const char * s = "hi";
  char * s1 = static_const<char *>(s);// 错误,不去去掉顶层const
  string s2 = static_const<string>(s);// 正确
  ```

* `const_cast<T>` —— 将非底层 const 转为 const，或者逆过来，逆过来转换时可以成功的，但是修改会报错。

* `reinterpret_cast<T>` —— 以较低层次位模式重新解释变量

### 3.6 语句

语句大体可分为：

1. 声明语句
2. 赋值语句
3. 消息语句
4. 函数原型
5. 函数调用语句
6. 返回语句

语句内部可以嵌套语句，主语句结束需要有结束标记；C++ 与 C 都以分号 `;` 为一条语句的结束。

语句可存在于函数块，循环块，逻辑执行块内部，声明语句还可以存在于函数外部表示全局变量，使用 `extern` 关键字还可拓展变量范围至所有引入文件。

**空语句**

单独一个分号`;`即是一个空语句，一般用在不需要循环体的 while 语句。

**语句块**

使用大括号括起来的语句集合称为语句块，语句块内定义的变量只在当前块内有效。if，while，for 等控制结构内定义的变量也只在对于语句块内有效。

### 3.7 条件语句

以下为具体的条件和循环语句

**if**

```cpp
if(test-expression) {
    
} else if(test-expression) {
    
} else {
    
}
```

**三元操作符**

```cpp
// test-expression 为真执行 expreesion1，为假执行 expreesion2
(test-expression) ? (expreesion1) : (expreesion2)；
```

**switch**

```cpp
switch(integer-expression) {
    case value:
        break;
    default:
}
//需要注意的是，当第一个case条件满足时，就不再判断后面的 case 条件，
//将会逐条执行语局，直到 break 或 块结束
```

### 3.8 循环语句

**for**

```cpp
//普通 for 循环
for(initializtion; test-expression; update-expression) {
    //body
}

//foreach 
for(arg : set-type) {
    //body
}

```

**while**

```cpp
while(test-expression) {
    //body
}

do {
    //body
} while (test-expression);
```

### 3.9 跳转语句

跳出整个循环：break;

跳出当前循环：continue；

### 3.10 try 语句块和异常处理

throw 语法：

```cpp
if(a == b)
	throw runtime_error("msg");
```

try语法：

```cpp
try {
	//...    
} catch (runtime_error err) {
    
}
// cpp 没有 finally，当异常所有的 catch 都没捕获到会转到 terminate 的标准库函数，该库函数行为与系统有关。
```

**标准异常**

标准异常位于头文件 \<stdexcerpt\> 中，包括：

* exception —— 通用
* runtime_error —— 运行时才能监测异常，同 JAVA 的受检异常相同
* range_error —— 结果超出有意义的范围
* overflow_error —— 计算结果上溢
* underflow_error —— 计算结果下溢
* logic_error —— 逻辑错误，同 JAVA 的运行时异常
* domain_error —— 逻辑错误：参数对应的结果不存在
* invalid_argument —— 逻辑错误：参数无效
* length_error —— 逻辑错误：试图创建一个超出该类型最大长度的对象
* out_of_range —— 逻辑错误：使用的值超过有效范围

**段错误**

一旦一个程序发生了越界访问，cpu 就会产生相应的保护，于是 segmentation fault 就出现了，通过上面的解释，**段错误应该就是访问了不可访问的内存**，这个内存区要么是不存在的，要么是受到系统保护的，还有可能是缺少文件或者文件损坏。 

产生原因：

1. 访问不存在的地址

   ```cpp
   int * p= nullptr;
   * p = 1; // 段错误
   ```

2. 访问受系统保护的地址

   ```CPP
   int * p= (int *) 0;
   * p = 1; // 段错误
   ```

3. 对只读的地址写操作

   ```cpp
   char *ptr = "test"; // ptr 指针指向一块只读区域
   strcpy(ptr, "TEST");
   ```

## 4. 函数

C++ 的函数大体与 C 相同。只是多了一些新特性。

函数声明（或称为函数原型）仍是由返回值、函数名称以及参数类型列表组成，如`int func(int, char);`

函数定义与声明多了大括号括起来的函数体：`int func(int n, char c){ //... }`。可以在声明的同时定义。

在使用函数之前，可以不进行函数定义，但必须有函数声明。

**C++ 的标准入口函数**

```cpp
//不带命令行参数的
int main(){
    return 0;
}

//带命令行参数的
//@param argc 值为 argv 的数组长度，至少为1，详见 argv[0]
//@param argv 至少含有一个 argv[0] 为程序的绝对路径，argv[1] 为程序的第一个参数，依此类推
int main(int argc, char[] argv) {
    
}
```

### 4.1 函数参数

有两种传递方式：

1. pass-by-value
2. pass-by-reference

函数参数默认都是**按值传递**，如

```cpp
int f(int n);

int main() {
    int a = 1;
    f(a);
}
```

f(a) 在调用时，会先分配好形参 n 的空间，然后将实参 a 的值赋给 n，所以函数体内 n 的改变不会影响到 a。

当传递数组名时，会把数组名解释为指针传给形参。所以，形参不会把该指针解释为数组（尽管它们指向同一个地址），这个可以又 sizeof 来验证，所以无法使用 sizeof 传进来的数组地址形参来获取数组长度，必须使用一个变量来传数组长度。

> 对于多形参，一般情况下编辑器是从右向左压栈的

但是对于一个大的结构体或类来说，按值传递就效率比较低了，而又是指针传递写起来比较麻烦，且会改变数组名的语义，这时可以使用**按引用传递**。

```cpp
int f(int &n); // 引用不分配形参空间，直接在原地址上操作
int farr(int (&arr)[10]); // 仍然保持数组名的语义，但必须传进来的是 10 大小的数组
```

> **引用符号与数组联合使用时的语义**
>
> int (&arr)[10] —— arr 是一个10大小数组的引用，数组的每个元素类型为 int
>
> int &(arr[10]) —— arr 是一个10大小的数组名，数组的每个元素类型为 int &，这种数组编译器一般不支持
>
> 由于[] 的优先级高于 & 所以，数组的引用必须加括号
>
> **const 引用与临时变量**
>
> 当实参和引用形参变量类型不一致时，如形参为 `int &` 实参为 `long`，形参为 `long &` 实参为 `int`，这都是不被编译器允许的。但是，当引用形参为 const 时，实参如果可以强转为形参，那么这样的调用是允许的。原理就是，强转生成对应类型的匿名临时变量，引用形参指向这个匿名变量，这个匿名变量的生命周期和函数调用周期一致。
>
> 其他当实参不具有名字是，其传给 const 引用形参也都会生成一个匿名临时变量。比如实参直接通过字面量或计算得来，如 `f(5),f(a + 2)`

使用 pass-by-reference （按引用传递）的原因主要有两个：

- 要修改数据对象
- 数据对象过大，为了提升效率，传引用

**函数参数使用建议**

对于实参只做使用不做修改的：

- 如果对象很小，则按值传递
- 如果对象是数组，则使用指针，这也是唯一的选择
- 如果对象较大，则使用 const 引用或 const 指针，以提高效率
- 如果对象是类对象，则使用 const 引用

对于实参要做修改的：

- 如果对象是内置数据类型，则使用指针
- 如果对象是数组，则只能使用指针
- 如果对象是结构体，则使用引用或指针
- 如果对象是类对象，则使用引用

以上只是建议，具体如何使用还要看具体需求。

#### 4.1.1 数组传参

**参数为一维数组**

当传一个一维数组参数时可以这样写：

```cpp
int f(int arr[]，int size)；
//访问可以使用 *(arr + i)
//也可以使用 arr[i] ，等价于 *(arr + i);
```

不过需要注意的是，arr虽然后面跟了数组的中括号，但其实是一个指针，所以必须有参数传入数组大小。

不能让数组传引用吗？当然可以，但是必须数组引用必须指定数组的大小，如：

```cpp
int f(int (&arr)[10]);

//下面的写法是错误的
int f(int (&arr)[]);
```

所以，数组传引用就会使参数很局限，不能传其他大小的数组，更多的时候，还是使用指针来传数组。

**参数为多维数组**

参数为多维数组时，我们可以将多维数组除第一维外直接指定为固定大小，第一维长度通过参数传递。如：

```cpp
int f(int arr[][10], n); //这样编译器就知道一个 arr之指针指向一块大小为 10 * sizeof(int) 字节的区域
//访问 arr[i][j] 等价于 *(*(arr + i) + j), arr 可以正确的使用指针加法
```

也可以使用多个参数将多个维度传进来。如：

```cpp
//下面这种传递访问就只能用 arr[i * m + j]来访问了，而不能用 arr[i][j]，因为此时arr是一维数组
//实参arr[][] 参数要传 arr[0]
int f(int * arr, int n, int m);

//以下的传递方式传递 arr[][] 都是非法的
int f(int **arr, int n, int m); //int ** 与 int[][] 不同，根本原因是二维大小为指定，原因参见本段代码后的解释
int f(int * arr[],int n, int m); // 二维大小未指定
```

> **\[\] 与 \* 和 \[\]\[\] 与 \*\***
>
> `arr[n]` 与` * p`，可以相互进行转换，编译器认为是无关紧要的转换
>
> 但 `arr[n][m]` 与 `** p` 则属于两种无法转换的类型，因为 `* p` 是一个指针，其长度定义与 [m] 不匹配，
>
> 那么如何声明一个多维数组的指针变量呢？如下
>
> ```cpp
> // 必须指定二维大小
> int (*p)[10][10] = arr;// int arr[10][10][10];
> ```
>
> 左边的 p 是 `int[10][10] *`型的，即 p 是一个指针，单位大小为 `int[10][10]`，这和 `arr[]` 同义，即 `arr[]` 要转换为 `* p`，而它们属于无关紧要的转换。

**使用 const 保护数组**

当我们不需要需改数组的元素值时，就应当使用 const 将数组保护起来，避免数据被修改，如：

```cpp
int f(const int arr[]); // 这样就无法通过arr[i]的方式修改数组元素了。
```

#### 4.1.2 C 风格字符串传参

传递 C 风格字符串的方式可以认为有两种：

1. char 数组指针
2. 字面量

不论哪种方式，由于 C 风格字符串规定必须以 `\0` 结尾，所以一般我们可以不用传 char 数组的长度，就可以判断字符串的结尾位置。

当不希望或者不需要改变字符串内容时，应当定义形参为 const 从而把字符串保护起来。

#### 4.1.3 给 main 函数传参

在生成可执行文件后，通过执行在命令行执行可执行文件并附加参数，可以将参数传给 main 函数使用。

```cpp
// argc 是数组 argv 的个数
// argv 为参数数组，argv 的第一个参数 argv[0] 为文件名或空字符串。所以 argc 至少为 1。
int main(int argc, char * argv[]);
```

### 4.2 默认参数 & 可变参数

**（一）默认参数**

C++ 允许指定默认参数，方法是在函数原型中指出，方法定义时可以不指出。如：

```cpp
void f(char, int a = 1);

f('c');// 不传a, a默认是1
```

默认参数只能出现在参数列表的最右边。

**（二）可变参数**

C11 提供了两种方式传递可变参数，一种是使用 initializer_list 模板类，一种是可变参数模板（参见模板章节）。

**initializer_list 模板类**

initializer_list 由于是泛型模板，所以一个列表只能传一种类型。提供了begin() 和 end() 迭代器，以及 size() 方法。还有默认构造方法和列表构造方法，以及拷贝构造方法。使用示例：

```cpp
int f(int n, initializer_list<char> ll);

//使用
f(5, {'1','2','f'});
```

**省略符形参**

C 语言使用省略符实现可变参数，但是省略符对 C++ 的支持却不是很好，尤其在类对象传递时大多数都不能正确拷贝。其原理很简单，就是根据参数列表算出参数在栈中的位置，然后读取。

所以只有当需要和 C 兼容时才考虑使用省略符形参。

```cpp
#include <stdio.h> 
#include <stdarg.h> 

void ArgFunc(const char *str, ... ) { 
    va_list ap; // 首先需要定义形参列表变量

    int n = 3; 
    char *s = NULL; 
    int d = 0; 
    double f = 0.0; 

    va_start(ap, str); // 先指定参数列表中可变参数的起始位置，即过滤掉 str 

    s = va_arg(ap, char*); //从左向右读
    d = va_arg(ap, int); 
    f = va_arg(ap, double);

    va_end(ap); 

    printf("%s is %s %d, %f", str, s, d, f); 
}
```

### 4.3 函数的返回值

**（一）非引用类型返回**

对于不超过 4 字节的返回值，一般存在 EAX 寄存其中。

对于结构体或类等较大的类型，则一般使用一个临时区域存放，这个临时区域的生成一般由编译器生成一个临时变量，并把这个变量作为额外的引用参数来调用，最后再把这个临时变量的值赋给需要的变量。如：

```cpp
//源调用
a = f();
// 将会被编译器转化为
T temp;
void f(T& temp) {
    T ret;
    //do sth
    temp = ret; //调用拷贝构造函数
    return;
}
a = temp; // 调用拷贝构造函数

//源调用2
f().p();
//将会被编译器转化为
T temp;
(f(T& temp), temp).p();
```

从上面的可以看的出来，获取一个返回值经过了两次拷贝函数的调用，这将严重影响效率。怎么解决呢？

1. 在使用者层面做优化，利用构造函数做优化

   ```cpp
   //源代码
   T bar(const X & z) {
       return T(z);
   }
   //编译器转化
   void bar( T & temp，const X & z) {
       temp.T::T(z);	//直接调用，无需拷贝
   	return;
   }
   ```

2. 在编译器层面做优化，有个优化操作称为 Named Return Value，将局部返回值变量直接用传入的引用取代

   ```cpp
   //源调用
   a = f();
   // 将会被编译器NRV优化为
   T temp;
   void f(T& temp) {
       temp.T::T();
       //do sth
       return;
   }
   a = temp; // 调用拷贝构造函数
   ```

经过上述介绍，应该知道下面几种写法的优劣：

```cpp
X x(1); // 此种效率最高
X x = X(1); // 需要生成临时变量
X x = (X) 1; // 需要创建临时变量，仍然调用的是 X(1) 构造函数。
```

**（二）引用类型返回**

当返回一个引用时，编译器就不需要生成临时变量了，应为可以直接使用引用值，所以避免由返回值向临时变量的拷贝。

但要注意的是，不能返回一个局部变量的引用。或者说，返回的引用必须在函数调用完成之后仍然存在且可以正常访问。

### 4.4 函数指针

C++ 支持函数式编程，所以可以定义函数指针的变量，定义时需要指明函数的返回值和参数列表，如

```cpp
// 下面定义了一个函数返回值为 double ，参数为 int 和 char 的函数指针
// fd 必须使用括号括号括起来的指针形式，因为 fd 优先与后面的参数列表结合会造成语义错误
double (*fd)(int, char) f;

// 调用，以下两种方法都在C++中合法。因为 fd 和 *fd 值完全相同
(* fd)(1, 'a');
fd(1, 'a');
```

### 4.5 函数重载

重载也是方便函数调用的一种方式。当两个函数名字相同，但参数列表不同，它们会被视为重载。

但是类型引用和类型本身将不会被视为重载，而会被视为相同的函数，编译器也不允许这样两个函数出现。如:

```cpp
int f(int);
int f(int &); // 编译时报错
```

当默认参数导致和函数重载相同时，也会报错。如：

```cpp
int f(int a, int b = 1);
int f(int a); // 编译时报错
```

**编译器如何选择重载版本**

这个策略可能会相对复杂，但大体上分三步：

1. 创建候选列表。将所有同名函数作为候选。

2. 选择出可行函数函数列表。可行函数包括了直接调用的和经过隐式类型转换可以匹配的函数列表。

   隐式转换主要指的是类型提升的转换（如 int 提升为 long，float 提升为 double）或模板提升匹配

3. 确定最佳可行函数。

下面主要介绍最佳可行函数顺序：

1. 完全匹配

   完全匹配包括了不转换，和一些无关紧要的转换，下面列出了一些无关紧要的转换

   |   从形参    |       到实参       | 从形参 |   到实参    |
   | :---------: | :----------------: | :----: | :---------: |
   |      T      |        T &         |   T    |   const T   |
   |     T &     |         T          |   T    | volatile T  |
   |     T[]     |        \* T        |  T \*  | const T \*  |
   | T(arg-list) | T  (\*) (arg-list) |  T \*  | volatile \* |

   这些无关紧要的转换函数如果存在多个（包括不转换的函数），编译器将报错

2. 提升转换

   类似于 int 提升为 long，float 提升为 double

3. 标准转换

   指 int 转为 char，long 转为 double 等

4. 用户定义的转换

   如类声明中定义的转换

多个参数的重载顺序更为复杂，大体准则为，最优的函数的所有参数全优于其他参数，或至少有一个参数优于其他函数。

### 4.6 命名空间

可以为函数指定命名空间，来防止重名

```cpp
//定义
namespace ns1 {
    namespace ns2 {
        int func() {
            //...
        }
    }
}

//使用方式 1
ns1::ns2::func();

//使用方式 2
//先指定默认的命名空间
using namespace ns1::ns2;
func();
```

### 4.7 内联函数 & constexpr 函数

**内联函数**

内联函数在编译时直接将函数在当前位置展开，避免了函数调用寻找函数地址的消耗，当然，缺点的是会多占用内存空间，不易不适合太长的函数。

内联函数在声明和定义时均需要在函数名前添加 inline 关键字。

**constexpr 函数**

constexpr 函数指能返回常量表达式，且有且只有一条返回语句的函数，示例如下:

```cpp
constexpr int getSize() {
    return 1;
}

//也允许不返回常量
constexpr int getN(int n) {
    return getSize() * n;
}

// 当 n 是常量表达式时，返回的是常量表达式，否则不是
int arr[getN(2)]; //正确，2 是常量表达式
int a = 2;
int arr[getN(a)]l //错误，a 不是常量表达式
```

## 5. 动态内存 TODO

#### 1.4.1 malloc & free

```cpp
//申请空间但不初始化，申请失败是返回 NULL
int * p = (int *) malloc(100); // p 指向一个大小为 100 字节的内存的地址
int * p = (int *) malloc(25*sizeof(int)); // p 指向一个 25 个 int 整型空间的地址

//申请空间并且全部初始化为0，失败返回 NULL
int * p = (int *) alloc(10, sizeof(int)); // p 指向一个 10 个 int 整型空间的地址

//重新分配空间
//如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，且不进行初始化。
//如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。
//如果缩小内存，则原来内存块从尾部进行删减。
int * p = (int *) realloc(p, 10);// 调整为10字节大小
   
free(p);// 释放空间
```

#### 1.4.2 new & delete

```cpp
//申请单个空间，申请失败抛出 bac_alloc 异常。
int * pi = new int; // 未初始化
int * pi = new int();// 初始化为 0
int * pi = new int(1024);// 初始化为 1024

delete pi; pi = nullptr; //释放单个空间

//申请数组空间
int * pi = new int[n]; // 未初始化
int * pi = new int[n](); // 全部初始化为 0
int * pi = new int[n]{1}; // 第一个元素初始化为1，其余初始化为 0 

delete [] pi; // 释放数组空间
```

**malloc 与 new 的区别**

- 属性—— new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要 C 头文件支持。
- 参数—— 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 
- 返回类型—— new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 
- 分配失败—— new 内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- 对类的支持——new 会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
- 重载—— C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。 
- 内存区域—— new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 

> 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；
>
> 在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；





## 6. 函数模板——泛型

## 7. 类

## 8. 内存模型

## 9. IO（输入与输出）

标准输入输出重定向

```cpp
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```

### 1.7.1 scanf & printf

**（一）scanf**

以下是三个格式化输入函数：

```cpp
#include<cstdio> 

int scanf( const char* format, … ); // 从标准输入输入
int fscanf( std::FILE* stream, const char* format, … ); //从文件输入
int sscanf( const char* buffer, const char* format, … ); //从字符串输入
```

返回值：成功读入数据域（如一个 `%d`  ）的个数。

**一个输入数据域的开始和结束**

- **%c**——读入一个字节，无论是什么字节字符
- **%[abcd]**——读取到非格式内的其他字符结束，也可以取反 %\[^abcd\]，表示读取到格式内的任意字符结束
- 其他如 %d,%o,%x,%f,%s 的结束判断（这些数据域的开始会忽略空白字符）
  - 遇到空白字符
  - 遇到宽度结束
  - 遇到非法输入

**当数据域类型不匹配时**

直接返回当前 scanf，之前已匹配到的数据可以正常读取。

> scanf 每次从缓冲区匹配一个数据域，无论类型匹配与否，都会把缓冲区的指针后移。

**其他注意事项**

- scanf 读入 string 需要使用`scanf("%s",s.c_str())`；
- scanf 遇到空白字符结束读入，这个空白字符仍保留在输入流当中。
- 有时程序会没有判断输入结束。在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键，即可结束输入。在Linux下，输入完毕后按Ctrl＋D键即可结束输入。

**（二）printf**

#### 1.7.2 getchar & putchar

#### 1.7.3 gets & puts

#### 1.7.4 cin & cout

## 10. STL

### 6.1 vector

头文件：`#include <vector>`

vector 是一个泛型动态数组，相当于 java 的 ArrayList。与 java 不同的是，泛型可以是内建的 int ，double 等类型。

**属性和类型介绍**

* size —— 数组当前大小，指存的元素个数
* capacity —— 当前数组的容量，超过这个容量就要扩容
* vector\<T\>::iterator —— 迭代器类型

**构造方法**

* vector(void) —— 默认构造，size 和 capacity 都为零。
* vector(int size) —— 构造 size 个元素的数组，每个元素进行默认的初始化。
* vector(int size, T initial_value) —— 构造 size 个元素的数组，每个元素进行指定初始化。
* vector(vector\<T\> v) —— 拷贝构造
* vector(vector\<T\>::iterator begin, vector\<T\>::iterator end) —— 使用迭代器内的元素构造。
* vector 也支持数组的大括号初始化，如 `vector<int> {1,2}`

**运算符重载**

* operator[] —— 使之支持静态数组的访问方式

**成员方法**

* at(int index) ——传回索引 index 所指的数据，如果越界，抛出out_of_range。
* push_back(T value)
* pop_back()
* front() —— 传回第一个数据
* back() —— 传回最后一个数据，不检查这个数据是否存在。 
* swap(int idx1, int idx2)
* insert(int pos, T value) 
* insert(int pos, int n, T value)
* insert(int pos, vector\<T\>::iterator begin, vector\<T\>::iterator end)
* assign(int n, T value)
* assign(vector\<T\>::iterator begin, vector\<T\>::iterator end)
* begin() 
* end()
* clear() 
* size()
* max_size()
* empty() 
* resize(int size)
* reserve() —— 保留适当的容量
* rbegin() 
* rend() 

### 6.2 list

头文件：`#include <list>`

C++ 中的双向链表，类似于 java 的 LinkedList。

**属性和类型介绍**

- size —— 链表当前大小
- li's't\<T\>::iterator —— 迭代器类型

**构造函数**

* list()
* list(int size)
* list(int size, T initial_value)
* list(list<T\> l)
* list(list\<T\>::iterator begin, list\<T\>::iterator end)

**成员函数**

* push_front(T value)
* pop_front()
* push_back(T value)
* pop_back()
* front() —— 传回第一个数据
* back() —— 传回最后一个数据，不检查这个数据是否存在。 
* insert(list\<T\>::iterator pos, T value)
* remove(T value) ——删除所有值为value的元素
* unique() ——删除所有重复的元素
* begin() 
* end()
* size()
* clear() 
* empty() 

### 6.3 set

### 6.4 map

头文件：`#include <map>`

map 即 C++ 的映射表。

**属性和类型介绍**

- size —— 数组当前大小，指存的元素个数
- map \<K，V>::iterator —— 迭代器类型

**构造方法**

- map (void) —— 默认构造。
- map (map \<K，V> m) —— 拷贝构造
- map (map \<K，V>::iterator begin, map \<K，V>::iterator end) —— 使用迭代器内的元素构造。

**运算符重载**

- operator[] —— 使之支持数组的访问方式，下标为key

**成员方法**

- at(int index) ——传回索引 index 所指的数据，如果越界，抛出out_of_range。
- push_back(T value)
- pop_back()
- front() —— 传回第一个数据
- back() —— 传回最后一个数据，不检查这个数据是否存在。 
- swap(int idx1, int idx2)
- insert(int pos, T value) 
- insert(int pos, int n, T value)
- insert(int pos, vector\<T\>::iterator begin, vector\<T\>::iterator end)
- assign(int n, T value)
- assign(vector\<T\>::iterator begin, vector\<T\>::iterator end)
- begin() 
- end()
- clear() 
- size()
- max_size()
- empty() 
- resize(int size)
- reserve() —— 保留适当的容量
- rbegin() 
- rend() 

### 6.5 deque

头文件：`#include <deque>`

双端队列。

**属性和类型介绍**

- size —— 链表当前大小
- deque\<T\>::iterator —— 迭代器类型

**构造函数**

- deque()
- deque(int size)
- deque(int size, T initial_value)
- deque(deque<T\> l)
- deque(deque\<T\>::iterator begin, deque\<T\>::iterator end)

**运算符重载**

- operator[] —— 使之支持数组的访问方式，但效率较低

**成员函数**

- at(int idx)

- push_front(T value)
- pop_front()
- push_back(T value)
- pop_back()
- front() —— 传回第一个数据
- back() —— 传回最后一个数据，不检查这个数据是否存在。 
- begin() 
- end()
- size()
- max_size()
- clear() 
- empty()

### 6.6 stack

头文件：`#include <stack>`

栈，由 deque 装饰而来。

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- stack()

**成员函数**

- push(T value)
- pop()
- top() —— 返回栈顶 
- size()
- clear() 
- empty()

### 6.7 queue

头文件：`#include <queue>`

普通队列，也是由 deque 装饰而来。

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- queue()

**成员函数**

- push(T value)
- pop()
- front()
- back()
- size()
- clear() 
- empty()

### 6.8 priority_queue

头文件：`#include <queue>`

优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队 

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- priority_queue\<type, container, compare\>() —— 
  - container 取值，默认为 vector
  - compare 的取值：greater\<int\> 从大到小（默认），less\<int\> 从小到大，需要重载大于小于运算符

**成员函数**

- push(T value)
- pop()
- top()
- size()
- clear() 
- empty()

### 6.9 pair

头文件：`#include <utility> `

pair 存储两个泛性值，pair 支持比较，首先比较第一个，第一个相同则以第二个大小关系为准。

**构造方法**

* pair()
* pair(v1, v2)
* 也可使用make_pair(v1,v2) 构造pair

**属性**

* first
* second

## 11. C 函数库

### 字符函数库 cctype

* int islower(char) —— 小写字母返回 1，否则返回 0
* int isupper(char)—— 大写字母返回 1，否则返回 0

* int isalpha(char) —— 字母返回 1，否则返回 0
* int isdigit(char)—— 数字返回 1，否则返回 0
* int isalnum(char) —— 数字或字母返回 1，否则返回 0
* int isxdigit()—— 十六进制字符返回 1，否则返回 0
* int isblank(char) —— 空格或制表符返回 1，否则返回 0
* char tolower(char)—— 大写字母则返回对于小写字母，否则返回本身
* char toupper(char)—— 小写字母则返回对于大写字母，否则返回本身

# 参考文档

1. 《Effective c++》中文第三版
2. 《C++ Primer》第五版