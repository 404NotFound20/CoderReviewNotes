# C++ 基础 #

## 引言

无论什么时候接触 C++，都应该视 C++ 为一个语言联邦（这个概念来源于《Effective C++》），这个联邦的主要子语言包括：

* **C** —— C++ 是以 C 语言为基础。区块、语句、预处理器、内置数据类型、数组和指针等都来源于 C。
* **Object-Oriented C++** —— 这部分也是 C with classes 的诉求：classes（包括构造函数和析构函数）、封装、继承、多态、虚函数......等等面向对象的实施。
* **Template C++** —— 泛型编程，Template 相关考虑和设计已经弥漫到了整个 C++。
* **STL** —— STL 是个 Template 程序库。它对容器，迭代器，算法以及函数对象的规约有者极佳的紧密配合与协调。

记住这几个子语言，当从一个子语言切换到另一个子语言，导致编程守则的转换是十分自然的。本片文档的介绍也主要按照这四个子语言顺序来记录的。

## 1.C++ 基础

### 1.1 C++ 与 C 的交叉基础

#### 1.1.1 预处理

预处理（或称预编译）是指在进行编译的第一遍扫描（词法扫描和语法分析）之前所作的工作。预处理指令指示在程序正式编译前就由编译器进行的操作，可放在程序中任何位置。 C++ 完全继承了 C 的预处理功能。

**文件包含**

```cpp
// 直接在包含文件目录中去查找(包含目录是由用户在设置环境时设置的include目录)
#include <文件名>
// 首先在当前源文件目录中查找，若未找到才到包含目录中去查找
#include "文件名"
```

**条件编译**

```cpp
//只有定义了宏名才编译 ifdef 定义内的语句
#ifdef 宏名
//[#else]
#endif

//只有未定义宏名才编译 ifndef 定义内的语句
#ifndef 宏名
//[#else]
#endif

//只有常量表达式非 0 才编译 if 定义内的语句
#if 常量表达式
//[#else]
#endif
```

**宏定义**

在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代换，这称为宏替换或宏展开。 

使用方法如下：

```cpp
// #defind 宏名 字符串
#define MAX 100

// #defind 宏名(参数) 字符串
#define MAX(A,B) ((A) > (B) ? (A) : (B))

// 字符串化，使用 # 将字符串用双引号包围起来
// 以下两种写法作用相同
#define MAKESTR(name) #name 
#define MAKESTR(name) "name"

// 字符化，使用 #@ 将字符用单引号包围起来
// 以下两种写法作用相同
#define MAKECHAR(C) #@C 
#define MAKECHAR(C) `C`
```

宏定义的展开与先后顺序无关，预处理器是这样对宏替换的先将所有的宏定义收集起来，然后处理源代码，发现一个宏定义符就立即替换。 

而且，宏是预处理时的完全替换，没有任何语义的考虑，所以要使用括号区分歧义，否则可能就会逻辑错误。如

```cpp
#define ADD(A,B) A + B
ADD(1,2) * ADD(3,4)	//结果为11，因为宏展开为 1 + 2 * 3 + 4
```

ANSI 标准指定了 5 个内置宏定义，主要为调试使用

* \_\_LINE\_\_：当前源代码行号；
* \_\_FILE\_\_：当前源文件名；
* \_\_DATE\_\_：当前的编译日期
* \_\_TIME\_\_：当前编译时间；
* \_\_STDC\_\_：当要求程序严格遵循 ANSI C 标准时值为 1

#### 1.1.2 头文件

最新 C++ 的标准头文件都是没有扩展名的，如 `#include <iostream>`；

C 的标准文件在 C++ 中的头文件都被转为c开头，如 `#include <cmath>`

#### 1.1.3 语句

语句大体可分为：

1. 声明语句
2. 赋值语句
3. 消息语句
4. 函数原型
5. 函数语句
6. 返回语句

语句内部可以嵌套语句，主语句结束需要有结束标记；C++ 与 C 都以分号 `;` 为一条语句的结束。

语句可存在于函数块，循环块，逻辑执行块内部，声明语句还可以存在于函数外部表示全局变量，使用 `extern` 关键字还可拓展变量范围至所有引入文件。

#### 1.1.4 注释

C++ 的标准注释是双斜杠 `//`，同时也兼容了 C 的注释 `/* */`

> C99 标准也添加了 `//` 注释

### 1.2 变量类型和变量

变量的定义一般形式为 `变量类型 变量名`。

**（一）变量类型**

**所有内建类型**

* [unsigned] char —— 1个字节大小
* wchar_t —— 宽字符， 2个字节大小
* char16_t —— Unicode 字符，2个字节大小
* char32_t —— Unicode 字符，3个字节大小
* [unsigned] short —— 至少 2 字节大小
* [unsigned] int —— 至少和 short 一样大
* [unsigned] long —— 至少 4 字节大小，且至少和 int 一样大
* [unsigned] long long —— 至少 8 字节大小，C11新定义
* float —— 一般为 4 字节大小，浮点型的数据可以用 1.2e+10 表示，1位符号位，8位指数位，23 + 1位有效数字位
* double —— 一般为 8 字节大小，1位符号位，11位指数位，52 + 1位有效数字位
* bool —— 未定义最先尺寸，一般为 1 字节大小

**数组**

数组的一维大小可以在初始化时推断给出，高于一维的数组必须由常量指定。

```cpp
// 声明时必须给定数组大小
int arr[10];

//一维大小也可由推断得出。等号可不写
int arr[]{1,2};

//后面没有大括号的声明将不会初始化
//部分初始化，未初始化的元素将设为 0
int arr1[10];	// arr1[1] 未知，arr1[9] 未知
int arr2[10]{1, 2}; // arr2[1] 为 2，arr2[9] 为 0 
int arr2[][10]{{1,2},{2}};
```

> STL 提供了动态数组 vector，支持运行时指定大小和动态扩展。
>
> 以下是两种二维动态数组的声明方式：
>
> ```cpp
> // m, n 为整形变量，指定了二维动态数组的大小
> // 第一种
> int ** arr = new int *[m];
> for(int i = 0; i < m; ++i)
>     arr[i] = new int[n];
> 
> // 第二种
> vector<vector<int>> arr(m, vector<int>(n));
> 
> // 当二维可以设为常数大小时
> int (* arr)[5] = new int[n][5];
> ```

**字符串**

```cpp
// C 风格定义字符串，以下两种定义相同，需要注意的是，若 str 不指定 `\0`，将无法预料字符串的结尾
char str1[] = "abc";
char str2[] = {'a', 'b', 'c', '\0'};

// C++ 新增的 string 类，string 内部维护了一个字符串数组，并动态扩容
string s = str1;
```

string 重载了很多操作符，使得字符串连接和复制非常方便，无需使用 strcat() 和 strcpy()。使用 s.size() 即可获得字符串大小，相当于 strlen(s.c_str())。

**结构体**

```cpp
struct MyStruct {
    int a; //成员变量
    char b;
    
    void print() { //成员函数
        //...
    }
}; //声明语句，需要结束结构体声明

// C 中使用时，必须使用 struct 关键字
struct MyStruct ms1;
// C++ 中可以省略 struct 关键字
MyStruct ms2;

//结构体的初始化方式
//使用大括号的方式给结构体成员赋值，按照定义的顺序进行
ms2 = {1, 'a'}; 
//也可使用另一个结构体去初始化
MyStruct ms3 = ms2；
```

可以看的出，C++ 的结构体在 C 的基础上进行了扩展，且行为和类很像。

结构体的大小等于所有成员的大小之和加上8字节对齐填充的大小。

> 结构体还可以指定每个成员的位长度，如下
>
> ```cpp
> struct BitStruct {
>     int SN: 4;// SN 占 4 位
>     int: 4;// 跳过 4 位
>     bool T: 1; // T 使用 1 位
> }
> 
> //赋值和使用时可以像正常类型一样使用，但在赋值时只低位匹配的位数。
> ```

**联合体**

```cpp
union MyStruct {
    int a; //成员变量
    
    void print() { //成员函数
        //...
    }
};
```

联合体的大小等于所有成员的中的最大的成员大小加上8字节对齐填充的大小。

**枚举**

```cpp
enum E {a,b,c} //默认 a b c 整数值为 0 1 2
enum E2 {a = 10, b , c} //这时 a b c 的整数值为 10 11 12
enum E3 {a, b = 0, c} //这时 a b c 的整数值为 0 0 1，枚举的整数值允许重复
```

将枚举当作整数值计算不会有任何问题，但是将一个整数值赋给一个枚举是需要考虑的。所以枚举也没有自增操作。

通常将一个整形值强转为枚举值，在枚举范围内是被允许的，即便这个枚举值没有对应的元素。将一个整形值枚举的取值范围由枚举元素的最大整数值和最小整数值决定，范围上界为大于最大整数值的最小 2 次幂减 1，对于范围下界，当最小整数值大于等于 0 是，下界为0，否则，与寻找上界方式相同，但加上负号。如最大整数值 6，最小整数值为 -6，对应的上下界为 [7,-7]。对于有些编译器，可能并没有限制枚举范围。

**指针类型**

使用类型和 * 组合起来表示一个类型的指针类型，如 `int * p`，表示 p 是整型指针。

指针类型在声明时需要注意以下两点。

const 遇 * 截断修饰（也可以认为是优先级低，这里只是为了方便理解而定义）——意思就是当 const 遇到  * 时会把 * 和其之后的所有声明段看成整体来修饰。如：
```cpp
int a;
// 以下两种写法相同，const 修饰 *p，表示 *p 不能进行赋值操作（a 的值仍可改变，只是不能通过 *p）
int const * p = &a;
const int * p = &a;
// 下面的 const 修饰 p，表示 p 不能进行赋值，即 p 不能指向其他变量了
int * const p = &a;
```
\* 不能在声明时向后传递，如 `int * a, b;` ，a 是指针，b是整形。


**左值引用类型**

使用类型和 & 组合起来表示一个类型的左值引用类型，如 `int & p`，表示 p 是引用类型，引用类型在声明时必须初始化。引用类型变量相当于原变量的一个别名，用法和原变量完全一样，因为它们的地址完全相同。

一旦引用初始化后，就不能成为其他变量的引用了。所以 & 和 const 的没有顺序上的影响，无论 const 在什么位置，都表示引用变量不能进行赋值操作。

& 也不能在声明时向后传递。

当引用类型作为返回类型时需要注意不能返回一个临时变量的引用。

**右值引用类型**

使用类型和 && 组合起来表示一个类型的右值引用类型。右值引用可以用来接住右值实参，也可以用来接住一个右值返回值。从而避免拷贝构造函数的调用。

**（二）变量**

**变量名的要求**

- 由数字、字母和下划线组成，但不能以数字开头
- 双下划线开头和单下划线和大写开头的名称一般作为保留名称，留给编译器等使用
- C++ 没有长度要求，C 则最多智能识别 63 个字符，超过会阶段

**字面量值**

* 十进制整型——1
* 十六进制整型——0x10 == 16
* 八进制整型——010 == 8
* 浮点型 —— 3.14
* 浮点型科学表示 —— 3.14E0
* 字符 —— 'A'
* 转义字符 —— '\n\r\t\'；16 进制表示ascii 字符 —— '\x0f'；8 进制表示 ascii 字符 ——'\12'
* 字符串 —— “abc”；

> 整形字面量后缀
>
> u/U —— unsigned；l/L —— long；ll/LL —— long long
>
> 浮点型字面量后缀
>
> f/F —— float；d/D —— double
>
> 字符字面量前缀
>
> u —— char16_t；U —— char32_t；L —— wchar_t
>
> 字符串字面前缀
>
> u8 —— utf8 字符串

**隐式类型转换**

* 数值型 -> 布尔型，非 0 转为 true
* 布尔型 -> 数值型，true 转为 1
* 浮点 -> 整形，忽略小数点后的值
* 整形 -> 浮点，小数点后都为 0
* 无符号数赋值超范围，高出的位数截断
* 符号数超出范围，结果标准未给出定义
* 有符号转无符号，位模式不变

**强制类型转换**

C 风格：`(int) 1.2`，C++ 中仍可使用这种风格

C++ 新式风格 `int(1.2)`，更像是函数调用

### 1.4 动态申请空间

#### 1.4.1 malloc & free

```cpp
//申请空间但不初始化，申请失败是返回 NULL
int * p = (int *) malloc(100); // p 指向一个大小为 100 字节的内存的地址
int * p = (int *) malloc(25*sizeof(int)); // p 指向一个 25 个 int 整型空间的地址

//申请空间并且全部初始化为0，失败返回 NULL
int * p = (int *) alloc(10, sizeof(int)); // p 指向一个 10 个 int 整型空间的地址

//重新分配空间
//如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，且不进行初始化。
//如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。
//如果缩小内存，则原来内存块从尾部进行删减。
int * p = (int *) realloc(p, 10);// 调整为10字节大小
   
free(p);// 释放空间
```

#### 1.4.2 new & delete

```cpp
//申请单个空间，申请失败抛出 bac_alloc 异常。
int * pi = new int; // 未初始化
int * pi = new int();// 初始化为 0
int * pi = new int(1024);// 初始化为 1024

delete pi; pi = nullptr; //释放单个空间

//申请数组空间
int * pi = new int[n]; // 未初始化
int * pi = new int[n](); // 全部初始化为 0
int * pi = new int[n]{1}; // 第一个元素初始化为1，其余初始化为 0 

delete [] pi; // 释放数组空间
```

**malloc 与 new 的区别**

* 属性—— new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要 C 头文件支持。
* 参数—— 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 
* 返回类型—— new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 
* 分配失败—— new 内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
* 对类的支持——new 会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
* 重载—— C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。 
* 内存区域—— new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 

>  在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；
>
>  在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；

### 1.5 运算符

c++ 支持的算术运算符：

c++ 支持的位运算符：

c++ 支持的关系运算符：`<,<=,>,>=,==,!=`

c++ 支持的逻辑运算符：`&&,||,!`

c++ 支持条件运算符。

c++ 支持的赋值运算符：

c++ 支持逗号运算符。

运算符优先级：算关逻，条赋逗；

右结合运算符：单条赋。

### 1.6 条件与循环

以下为具体的条件和循环语句

**if**

```cpp
if(test-expression) {
    
} else if(test-expression) {
    
} else {
    
}
```

**三元操作符**

```cpp
// test-expression 为真执行 expreesion1，为假执行 expreesion2
(test-expression) ? (expreesion1) : (expreesion2)；
```

**switch**

```cpp
switch(integer-expression) {
    case value:
        break;
    default:
}
//需要注意的是，当第一个case条件满足时，就不再判断后面的 case 条件，
//将会逐条执行语局，直到 break 或 块结束
```

**for**

```cpp
//普通 for 循环
for(initializtion; test-expression; update-expression) {
    //body
}

//foreach 
for(arg : set-type) {
    //body
}

```

**while**

```cpp
while(test-expression) {
    //body
}

do {
    //body
} while (test-expression);
```

### 1.7 输入与输出

标准输入输出重定向

```cpp
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```

### 1.7.1 scanf & printf

**（一）scanf**

以下是三个格式化输入函数：

```cpp
#include<cstdio> 

int scanf( const char* format, … ); // 从标准输入输入
int fscanf( std::FILE* stream, const char* format, … ); //从文件输入
int sscanf( const char* buffer, const char* format, … ); //从字符串输入
```

返回值：成功读入数据域（如一个 `%d`  ）的个数。

**一个输入数据域的开始和结束**

- **%c**——读入一个字节，无论是什么字节字符
- **%[abcd]**——读取到非格式内的其他字符结束，也可以取反 %\[^abcd\]，表示读取到格式内的任意字符结束
- 其他如 %d,%o,%x,%f,%s 的结束判断（这些数据域的开始会忽略空白字符）
  - 遇到空白字符
  - 遇到宽度结束
  - 遇到非法输入

**当数据域类型不匹配时**

直接返回当前 scanf，之前已匹配到的数据可以正常读取。

> scanf 每次从缓冲区匹配一个数据域，无论类型匹配与否，都会把缓冲区的指针后移。

**其他注意事项**

- scanf 读入 string 需要使用`scanf("%s",s.c_str())`；
- scanf 遇到空白字符结束读入，这个空白字符仍保留在输入流当中。
- 有时程序会没有判断输入结束。在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键，即可结束输入。在Linux下，输入完毕后按Ctrl＋D键即可结束输入。

**（二）printf**

#### 1.7.2 getchar & putchar

#### 1.7.3 gets & puts

#### 1.7.4 cin & cout

### 1.2 关键字 & 操作符

**const**

const 修饰的变量不能进行赋值操作，当 const 遇到 * 时会修饰 * 和后面整个声明。

不能把一个 const 指针、引用或变量赋给一个非 const 指针或引用。

```cpp
const int a = 1;
//以下赋值时违法的,因为 a 的值就可能被改变了
int * b = &a;
int * const c = &a; // *c 仍可边
int & d = a;
```

> 形参指针应该尽可能的使用 const
>
> - 可以避免以外改变
> - const 可以接收 const 和非 const，而非 const 不能接收 const。

**sizeof**

返回变量或类型所占用空间的字节大小。

特别注意的，当这个变量是数组名（只读的）时，返回的是整个数组的字节大小，当数组名被赋给一个指针时，这个指针不会被解释为数组名，所以这个指针的 sizeof 只会返回指针变量所占空间的字节大小。

**星号（*）**

有两个作用：

- 在类型符后使用，表示是指针类型。具体查阅后面复合类型的章节。
- 在变量前使用，表示解引用。

> **数组指针**
>
> 首先看下数组的指针和指针的数组表示方法：`type (* variable_name)[...]`。
>
> 对于一维数组指针就是 `int (* p)` 去掉括号即 `int * p`；因为 p 之后是空白，括号打开不影响语义。
>
> 对于二维数组指针就是 `int (* p)[10]` ，必须指定第二维大小，高维数组大小必须指定各维度大小，第一维除外，也无法指定。同时括号不能少，打开括号 p 会先和后面的整体结合，而使 p 成为一个数组名，元素类型为` int *`。
>
> 下面是具体的示例和解读：
>
> ```cpp
> //int * 表示一个整形指针，直线一个 int 大小的区域
> //int (*)[5] 表示一个数组指针，该指针指向一块 int[5] 大小的区域
> //int (*)[5][5] 也是一个数组指针，该指针指向一块 int[5][5] 大小的区域
> int a[5]; 一维数组，数组名作指针时长度为一个 int 大小，即 int * 型
> int b[5][5]; 二维数组，数组名作指针时长度为 int[5] 大小，即 int (*)[5] 型
> int c[5][5][5]; 三维数组，数组名作指针时长度为 int[5][5] 大小，即 int (*)[5][5] 型
> 
> // 数组指针变量
> int (* pa) = a;// int (* pa) 也即 int * pa
> int (* pb)[5] = b;// 可以理解为 (* pb) == b[0] == (* b)
> int (* pc)[5][5] = c;
> 
> // 根据以上我们能够知道下面的赋值是错误的
> int ** pb2 = b; // 编译出错，类型不匹配，pb2 是一个 int 的二级指针，它的长度为一个 int * 大小
> 
> // 对于形参，数组参数的第一维 p[] 就相当于 (* p)
> void fa(int pa[]); // 相当于 fa(int (* pa));
> fa(a); // 调用正确
> void fb(int pb[][5]); // 相当于 fa(int (* pb)[5]);
> fb(b); // 调用正确
> void fc(int pc[][5][5]); // 相当于 fa(int (* pc)[5][5]);
> fc(c); // 调用正确
> 
> // 我们现在应该也能判断除下面的调用是不正确的
> void f(int * p[]); // 相当于 f(int * (* p));
> f(b);// 编译错误，类型不匹配
> 
> //以下是一个稍复杂的数组指针例子
> int ** (*b)[2]; // b 是一个二维数组指针，每个数组元素是 int ** 类型
> ```
>
> **函数指针**
>
> 函数指针的表示方法 `return_type (* variable_name)(type1 param1, type2 param2, ...)`。
>
> 其中括号也不能省，打开括号就不是指针定义了。因为 variable_name 会首先和参数列表结合，使得上式变成一个返回类型为 `return_type *` 的函数声明。
>
> 来看具体的示例和解读：
>
> ```cpp
> // 先声明一个函数
> void a();
> 
> // 一个合法的函数指针
> void (*pa)() = a;
> 
> // 一个错误的定义
> void * pa2() = a; // 左值不是一个变量，而是一个函数声明
> 
> //需要注意的使，C++ 为了更广泛的兼容，以下两种函数访问方式都正确
> (* pa)();
> pa();
> ```
>
> **两个比较复杂的指针使用**
>
> 第一个：
>
> ```cpp
> int   *(*p(int))[3];
> ```
>
> ()的优先级最高，因此p先与()结合，说明p首先是个函数，
>
> 再与括号内的int结合，说明函数的参数为一个int,
>
> 再与p前面的*结合，说明函数的返回值为一个指针A，
>
> 再与后面的[]结合，说明该指针A指向的内容是一个数组，
>
> 再与第一个*结合，说明数组里面的元素是指针B，
>
> 再与前面的int结合，说明指针B指向的内容是一个int。
>
> 第二个：
>
> ```cpp
> int (*(*p)(int))(int);
> ```
>
> ()的优先级最高，因此p先与*结合，说明p首先是个指针A，
>
> 再与后面()结合，说明该指针A指向的内容是一个函数A，
>
> 再与括号中的int结合，说明该函数的参数是一个int,
>
> 再与(*p)前面的*结合，说明该函数的返回值是一个指针B，
>
> 再与最后面的()结合，说明该指针B指向的内容提要是一个函数B，
>
> 再与括号中的int结合，说明该函数B的参数是一个int，
>
> 再与前面的float结合，说明函数B的返回值为float。

**AND符（&）**

& 有三个作用：

- 在类型符后使用，表示引用类型。具体查阅后面复合类型的章节
- 在变量前使用，表示取地址。
- 在两个整形变量之间使用，表示按位与。

> **数组引用**
>
> 数组引用和同数组指针定义类似：`type (& variable_name)[...]`。如:
>
> ```cpp
> int a[5];
> int b[5][5];
> 
> //数组引用变量定义，必须指定大小，包括一维
> int (& ra)[5] = a;
> int (& rb)[5][5] = b;
> ```
>
> 数组引用的语义和数组名的语义完全相同，而数组指针的语义仅仅是一个指针的语义。

## 2. 函数

C++ 的函数大体与 C 相同。只是多了一些新特性。

函数声明（或称为函数原型）仍是由返回值、函数名称以及参数类型列表组成，如`int func(int, char);`

函数定义与声明多了大括号括起来的函数体：`int func(int n, char c){ //... }`。可以在声明的同时定义。

**C++ 的标准入口函数**

```cpp
//不带命令行参数的
int main(){
    return 0;
}

//带命令行参数的
//@param argc 值为 argv 的数组长度，至少为1，详见 argv[0]
//@param argv 至少含有一个 argv[0] 为程序的绝对路径，argv[1] 为程序的第一个参数，依此类推
int main(int argc, char[] argv) {
    
}
```

### 2.1 函数传参

有两种传递方式：

1. pass-by-value
2. pass-by-reference

函数参数默认都是**按值传递**，如

```cpp
int f(int n);

int main() {
    int a = 1;
    f(a);
}
```

f(a) 在调用时，会先分配好形参 n 的空间，然后将实参 a 的值赋给 n，所以函数体内 n 的改变不会影响到 a。

当传递数组名时，会把数组名解释为指针传给形参。所以，形参不会把该指针解释为数组（尽管它们指向同一个地址），这个可以又 sizeof 来验证，所以无法使用 sizeof 传进来的数组地址形参来获取数组长度，必须使用一个变量来传数组长度。

> 对于多形参，一般情况下编辑器是从右向左压栈的

但是对于一个大的结构体或类来说，按值传递就效率比较低了，而又是指针传递写起来比较麻烦，且会改变数组名的语义，这时可以使用**按引用传递**。

```cpp
int f(int &n); // 引用不分配形参空间，直接在原地址上操作
int farr(int (&arr)[10]); // 仍然保持数组名的语义，但必须传进来的是 10 大小的数组
```

> **引用符号与数组联合使用时的语义**
>
> int (&arr)[10] —— arr 是一个10大小数组的引用，数组的每个元素类型为 int
>
> int &(arr[10]) —— arr 是一个10大小的数组名，数组的每个元素类型为 int &，这种数组编译器一般不支持
>
> 由于[] 的优先级高于 & 所以，数组的引用必须加括号
>
> **const 引用与临时变量**
>
> 当实参和引用形参变量类型不一致时，如形参为 `int &` 实参为 `long`，形参为 `long &` 实参为 `int`，这都是不被编译器允许的。但是，当引用形参为 const 时，实参如果可以强转为形参，那么这样的调用是允许的。原理就是，强转生成对应类型的匿名临时变量，引用形参指向这个匿名变量，这个匿名变量的生命周期和函数调用周期一致。
>
> 其他当实参不具有名字是，其传给 const 引用形参也都会生成一个匿名临时变量。比如实参直接通过字面量或计算得来，如 `f(5),f(a + 2)`

使用 pass-by-reference （按引用传递）的原因主要有两个：

- 要修改数据对象
- 数据对象过大，为了提升效率，传引用

**函数参数使用建议**

对于实参只做使用不做修改的：

- 如果对象很小，则按值传递
- 如果对象是数组，则使用指针，这也是唯一的选择
- 如果对象较大，则使用 const 引用或 const 指针，以提高效率
- 如果对象是类对象，则使用 const 引用

对于实参要做修改的：

- 如果对象是内置数据类型，则使用指针
- 如果对象是数组，则只能使用指针
- 如果对象是结构体，则使用引用或指针
- 如果对象是类对象，则使用引用

以上只是建议，具体如何使用还要看具体需求。

#### 2.1.1 数组传参

**参数为一维数组**

当传一个一维数组参数时可以这样写：

```cpp
int f(int arr[]，int size)；
//访问可以使用 *(arr + i)
//也可以使用 arr[i] ，等价于 *(arr + i);
```

不过需要注意的是，arr虽然后面跟了数组的中括号，但其实是一个指针，所以必须有参数传入数组大小。

不能让数组传引用吗？当然可以，但是必须数组引用必须指定数组的大小，如：

```cpp
int f(int (&arr)[10]);

//下面的写法是错误的
int f(int (&arr)[]);
```

所以，数组传引用就会使参数很局限，不能传其他大小的数组，更多的时候，还是使用指针来传数组。

**参数为多维数组**

参数为多维数组时，我们可以将多维数组除第一维外直接指定为固定大小，第一维长度通过参数传递。如：

```cpp
int f(int arr[][10], n); //这样编译器就知道一个 arr之指针指向一块大小为 10 * sizeof(int) 字节的区域
//访问 arr[i][j] 等价于 *(*(arr + i) + j), arr 可以正确的使用指针加法
```

也可以使用多个参数将多个维度传进来。如：

```cpp
//下面这种传递访问就只能用 arr[i * m + j]来访问了，而不能用 arr[i][j]，因为此时arr是一维数组
//实参arr[][] 参数要传 arr[0]
int f(int * arr, int n, int m);

//以下的传递方式传递 arr[][] 都是非法的
int f(int **arr, int n, int m); //int ** 与 int[][] 不同，根本原因是二维大小为指定，原因参见本段代码后的解释
int f(int * arr[],int n, int m); // 二维大小未指定
```

> **\[\] 与 \* 和 \[\]\[\] 与 \*\***
>
> `arr[n]` 与` * p`，可以相互进行转换，编译器认为是无关紧要的转换
>
> 但 `arr[n][m]` 与 `** p` 则属于两种无法转换的类型，因为 `* p` 是一个指针，其长度定义与 [m] 不匹配，
>
> 那么如何声明一个多维数组的指针变量呢？如下
>
> ```cpp
> // 必须指定二维大小
> int (*p)[10][10] = arr;// int arr[10][10][10];
> ```
>
> 左边的 p 是 `int[10][10] *`型的，即 p 是一个指针，单位大小为 `int[10][10]`，这和 `arr[]` 同义，即 `arr[]` 要转换为 `* p`，而它们属于无关紧要的转换。

**使用 const 保护数组**

当我们不需要需改数组的元素值时，就应当使用 const 将数组保护起来，避免数据被修改，如：

```cpp
int f(const int arr[]); // 这样就无法通过arr[i]的方式修改数组元素了。
```

#### 2.1.2 C 风格字符串传参

传递 C 风格字符串的方式可以认为有两种：

1. char 数组指针
2. 字面量

不论哪种方式，由于 C 风格字符串规定必须以 `\0` 结尾，所以一般我们可以不用传 char 数组的长度，就可以判断字符串的结尾位置。

当不希望或者不需要改变字符串内容时，应当定义形参为 const 从而把字符串保护起来。

#### 2.1.3 string 传参

//TODO

### 2.2 函数的返回值

**（一）非引用类型返回**

对于不超过 4 字节的返回值，一般存在 EAX 寄存其中。

对于结构体或类等较大的类型，则一般使用一个临时区域存放，这个临时区域的生成一般由编译器生成一个临时变量，并把这个变量作为额外的引用参数来调用，最后再把这个临时变量的值赋给需要的变量。如：

```cpp
//源调用
a = f();
// 将会被编译器转化为
T temp;
void f(T& temp) {
    T ret;
    //do sth
    temp = ret; //调用拷贝构造函数
    return;
}
a = temp; // 调用拷贝构造函数

//源调用2
f().p();
//将会被编译器转化为
T temp;
(f(T& temp), temp).p();
```

从上面的可以看的出来，获取一个返回值经过了两次拷贝函数的调用，这将严重影响效率。怎么解决呢？

1. 在使用者层面做优化，利用构造函数做优化

   ```cpp
   //源代码
   T bar(const X & z) {
       return T(z);
   }
   //编译器转化
   void bar( T & temp，const X & z) {
       temp.T::T(z);	//直接调用，无需拷贝
   	return;
   }
   ```

2. 在编译器层面做优化，有个优化操作称为 Named Return Value，将局部返回值变量直接用传入的引用取代

   ```cpp
   //源调用
   a = f();
   // 将会被编译器NRV优化为
   T temp;
   void f(T& temp) {
       temp.T::T();
       //do sth
       return;
   }
   a = temp; // 调用拷贝构造函数
   ```

经过上述介绍，应该知道下面几种写法的优劣：

```cpp
X x(1); // 此种效率最高
X x = X(1); // 需要生成临时变量
X x = (X) 1; // 需要创建临时变量，仍然调用的是 X(1) 构造函数。
```

**（二）引用类型返回**

当返回一个引用时，编译器就不需要生成临时变量了，应为可以直接使用引用值，所以避免由返回值向临时变量的拷贝。

但要注意的是，不能返回一个局部变量的引用。或者说，返回的引用必须在函数调用完成之后仍然存在且可以正常访问。

### 2.4 函数指针

C++ 支持函数式编程，所以可以定义函数指针的变量，定义时需要指明函数的返回值和参数列表，如

```cpp
// 下面定义了一个函数返回值为 double ，参数为 int 和 char 的函数指针
// fd 必须使用括号括号括起来的指针形式，因为 fd 优先与后面的参数列表结合会造成语义错误
double (*fd)(int, char) f;

// 调用，以下两种方法都在C++中合法。因为 fd 和 *fd 值完全相同
(* fd)(1, 'a');
fd(1, 'a');
```

### 2.2 默认参数

C++ 允许指定默认参数，方法是在函数原型中指出，方法定义时可以不指出。如：

```cpp
void f(int a = 1);

f();// 不传a, a默认是1
```

默认参数只能出现在参数列表的最右边。

### 2.3 函数重载

重载也是方便函数调用的一种方式。当两个函数名字相同，但参数列表不同，它们会被视为重载。

但是类型引用和类型本身将不会被视为重载，而会被视为相同的函数，编译器也不允许这样两个函数出现。如:

```cpp
int f(int);
int f(int &); // 编译时报错
```

当默认参数导致和函数重载相同时，也会报错。如：

```cpp
int f(int a, int b = 1);
int f(int a); // 编译时报错
```

**编译器如何选择重载版本**

这个策略可能会相对复杂，但大体上分三步：

1. 创建候选列表。将所有同名函数作为候选。

2. 选择出可行函数函数列表。可行函数包括了直接调用的和经过隐式类型转换可以匹配的函数列表。

   隐式转换主要指的是类型提升的转换（如 int 提升为 long，float 提升为 double）或模板提升匹配

3. 确定最佳可行函数。

下面主要介绍最佳可行函数顺序：

1. 完全匹配

   完全匹配包括了不转换，和一些无关紧要的转换，下面列出了一些无关紧要的转换

   |   从形参    |       到实参       | 从形参 |   到实参    |
   | :---------: | :----------------: | :----: | :---------: |
   |      T      |        T &         |   T    |   const T   |
   |     T &     |         T          |   T    | volatile T  |
   |     T[]     |        \* T        |  T \*  | const T \*  |
   | T(arg-list) | T  (\*) (arg-list) |  T \*  | volatile \* |

   这些无关紧要的转换函数如果存在多个（包括不转换的函数），编译器将报错

2. 提升转换

   类似于 int 提升为 long，float 提升为 double

3. 标准转换

   指 int 转为 char，long 转为 double 等

4. 用户定义的转换

   如类声明中定义的转换

多个参数的重载顺序更为复杂，大体准则为，最优的函数的所有参数全优于其他参数，或至少有一个参数优于其他函数。

### 2.5 命名空间

可以为函数指定命名空间，来防止重名

```cpp
//定义
namespace ns1 {
    namespace ns2 {
        int func() {
            //...
        }
    }
}

//使用方式 1
ns1::ns2::func();

//使用方式 2
//先指定默认的命名空间
using namespace ns1::ns2;
func();
```

### 2.6 内联函数

内联函数在编译时直接将函数在当前位置展开，避免了函数调用寻找函数地址的消耗，当然，缺点的是会多占用内存空间，不易不适合太长的函数。

内联函数在声明和定义时均需要在函数名前添加 inline 关键字。

最终是否以内联函数存在还是由编译器决定。

## 3. 函数模板——泛型

## 4. 类

## 5. 内存模型

## 6. STL

### 6.1 vector

头文件：`#include <vector>`

vector 是一个泛型动态数组，相当于 java 的 ArrayList。与 java 不同的是，泛型可以是内建的 int ，double 等类型。

**属性和类型介绍**

* size —— 数组当前大小，指存的元素个数
* capacity —— 当前数组的容量，超过这个容量就要扩容
* vector\<T\>::iterator —— 迭代器类型

**构造方法**

* vector(void) —— 默认构造，size 和 capacity 都为零。
* vector(int size) —— 构造 size 个元素的数组，每个元素进行默认的初始化。
* vector(int size, T initial_value) —— 构造 size 个元素的数组，每个元素进行指定初始化。
* vector(vector\<T\> v) —— 拷贝构造
* vector(vector\<T\>::iterator begin, vector\<T\>::iterator end) —— 使用迭代器内的元素构造。
* vector 也支持数组的大括号初始化，如 `vector<int> {1,2}`

**运算符重载**

* operator[] —— 使之支持静态数组的访问方式

**成员方法**

* at(int index) ——传回索引 index 所指的数据，如果越界，抛出out_of_range。
* push_back(T value)
* pop_back()
* front() —— 传回第一个数据
* back() —— 传回最后一个数据，不检查这个数据是否存在。 
* swap(int idx1, int idx2)
* insert(int pos, T value) 
* insert(int pos, int n, T value)
* insert(int pos, vector\<T\>::iterator begin, vector\<T\>::iterator end)
* assign(int n, T value)
* assign(vector\<T\>::iterator begin, vector\<T\>::iterator end)
* begin() 
* end()
* clear() 
* size()
* max_size()
* empty() 
* resize(int size)
* reserve() —— 保留适当的容量
* rbegin() 
* rend() 

### 6.2 list

头文件：`#include <list>`

C++ 中的双向链表，类似于 java 的 LinkedList。

**属性和类型介绍**

- size —— 链表当前大小
- li's't\<T\>::iterator —— 迭代器类型

**构造函数**

* list()
* list(int size)
* list(int size, T initial_value)
* list(list<T\> l)
* list(list\<T\>::iterator begin, list\<T\>::iterator end)

**成员函数**

* push_front(T value)
* pop_front()
* push_back(T value)
* pop_back()
* front() —— 传回第一个数据
* back() —— 传回最后一个数据，不检查这个数据是否存在。 
* insert(list\<T\>::iterator pos, T value)
* remove(T value) ——删除所有值为value的元素
* unique() ——删除所有重复的元素
* begin() 
* end()
* size()
* clear() 
* empty() 

### 6.3 set

### 6.4 map

头文件：`#include <map>`

map 即 C++ 的映射表。

**属性和类型介绍**

- size —— 数组当前大小，指存的元素个数
- map \<K，V>::iterator —— 迭代器类型

**构造方法**

- map (void) —— 默认构造。
- map (map \<K，V> m) —— 拷贝构造
- map (map \<K，V>::iterator begin, map \<K，V>::iterator end) —— 使用迭代器内的元素构造。

**运算符重载**

- operator[] —— 使之支持数组的访问方式，下标为key

**成员方法**

- at(int index) ——传回索引 index 所指的数据，如果越界，抛出out_of_range。
- push_back(T value)
- pop_back()
- front() —— 传回第一个数据
- back() —— 传回最后一个数据，不检查这个数据是否存在。 
- swap(int idx1, int idx2)
- insert(int pos, T value) 
- insert(int pos, int n, T value)
- insert(int pos, vector\<T\>::iterator begin, vector\<T\>::iterator end)
- assign(int n, T value)
- assign(vector\<T\>::iterator begin, vector\<T\>::iterator end)
- begin() 
- end()
- clear() 
- size()
- max_size()
- empty() 
- resize(int size)
- reserve() —— 保留适当的容量
- rbegin() 
- rend() 

### 6.5 deque

头文件：`#include <deque>`

双端队列。

**属性和类型介绍**

- size —— 链表当前大小
- deque\<T\>::iterator —— 迭代器类型

**构造函数**

- deque()
- deque(int size)
- deque(int size, T initial_value)
- deque(deque<T\> l)
- deque(deque\<T\>::iterator begin, deque\<T\>::iterator end)

**运算符重载**

- operator[] —— 使之支持数组的访问方式，但效率较低

**成员函数**

- at(int idx)

- push_front(T value)
- pop_front()
- push_back(T value)
- pop_back()
- front() —— 传回第一个数据
- back() —— 传回最后一个数据，不检查这个数据是否存在。 
- begin() 
- end()
- size()
- max_size()
- clear() 
- empty()

### 6.6 stack

头文件：`#include <stack>`

栈，由 deque 装饰而来。

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- stack()

**成员函数**

- push(T value)
- pop()
- top() —— 返回栈顶 
- size()
- clear() 
- empty()

### 6.7 queue

头文件：`#include <queue>`

普通队列，也是由 deque 装饰而来。

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- queue()

**成员函数**

- push(T value)
- pop()
- front()
- back()
- size()
- clear() 
- empty()

### 6.8 priority_queue

头文件：`#include <queue>`

优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队 

**属性和类型介绍**

- size —— 链表当前大小

**构造函数**

- priority_queue\<type, container, compare\>() —— 
  - container 取值，默认为 vector
  - compare 的取值：greater\<int\> 从大到小（默认），less\<int\> 从小到大，需要重载大于小于运算符

**成员函数**

- push(T value)
- pop()
- top()
- size()
- clear() 
- empty()

### 6.9 pair

头文件：`#include <utility> `

pair 存储两个泛性值，pair 支持比较，首先比较第一个，第一个相同则以第二个大小关系为准。

**构造方法**

* pair()
* pair(v1, v2)
* 也可使用make_pair(v1,v2) 构造pair

**属性**

* first
* second

## 7. C 函数库

### 字符函数库 cctype

* int islower(char) —— 小写字母返回 1，否则返回 0
* int isupper(char)—— 大写字母返回 1，否则返回 0

* int isalpha(char) —— 字母返回 1，否则返回 0
* int isdigit(char)—— 数字返回 1，否则返回 0
* int isalnum(char) —— 数字或字母返回 1，否则返回 0
* int isxdigit()—— 十六进制字符返回 1，否则返回 0
* int isblank(char) —— 空格或制表符返回 1，否则返回 0
* char tolower(char)—— 大写字母则返回对于小写字母，否则返回本身
* char toupper(char)—— 小写字母则返回对于大写字母，否则返回本身

# 参考文档

1. 《Effective c++》中文第三版
2. 《C++ Primer》第五版